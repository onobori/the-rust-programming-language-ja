<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>エラーハンドリング</title>

    <link rel="stylesheet" type="text/css" href="rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='getting-started.html'><b>2.</b> はじめる</a>
</li>
<li><a  href='learn-rust.html'><b>3.</b> Rustを学ぶ</a>
<ul class='section'>
<li><a  href='guessing-game.html'><b>3.1.</b> 数当てゲーム</a>
</li>
<li><a  href='dining-philosophers.html'><b>3.2.</b> 食事する哲学者</a>
</li>
<li><a  href='rust-inside-other-languages.html'><b>3.3.</b> 他言語と共存する</a>
</li>
</ul>
</li>
<li><a  href='syntax-and-semantics.html'><b>4.</b> シンタックスとセマンティクス</a>
<ul class='section'>
<li><a  href='variable-bindings.html'><b>4.1.</b> 変数束縛</a>
</li>
<li><a  href='functions.html'><b>4.2.</b> 関数</a>
</li>
<li><a  href='primitive-types.html'><b>4.3.</b> プリミティブ型</a>
</li>
<li><a  href='comments.html'><b>4.4.</b> コメント</a>
</li>
<li><a  href='if.html'><b>4.5.</b> if</a>
</li>
<li><a  href='loops.html'><b>4.6.</b> ループ</a>
</li>
<li><a  href='ownership.html'><b>4.7.</b> 所有権</a>
</li>
<li><a  href='references-and-borrowing.html'><b>4.8.</b> 参照と借用</a>
</li>
<li><a  href='lifetimes.html'><b>4.9.</b> ライフタイム</a>
</li>
<li><a  href='mutability.html'><b>4.10.</b> ミュータビリティ</a>
</li>
<li><a  href='structs.html'><b>4.11.</b> 構造体</a>
</li>
<li><a  href='enums.html'><b>4.12.</b> 列挙型</a>
</li>
<li><a  href='match.html'><b>4.13.</b> マッチ</a>
</li>
<li><a  href='patterns.html'><b>4.14.</b> パターン</a>
</li>
<li><a  href='method-syntax.html'><b>4.15.</b> メソッド構文</a>
</li>
<li><a  href='vectors.html'><b>4.16.</b> ベクタ</a>
</li>
<li><a  href='strings.html'><b>4.17.</b> 文字列</a>
</li>
<li><a  href='generics.html'><b>4.18.</b> ジェネリクス</a>
</li>
<li><a  href='traits.html'><b>4.19.</b> トレイト</a>
</li>
<li><a  href='drop.html'><b>4.20.</b> Drop</a>
</li>
<li><a  href='if-let.html'><b>4.21.</b> if let</a>
</li>
<li><a  href='trait-objects.html'><b>4.22.</b> トレイトオブジェクト</a>
</li>
<li><a  href='closures.html'><b>4.23.</b> クロージャ</a>
</li>
<li><a  href='ufcs.html'><b>4.24.</b> 共通の関数呼出構文</a>
</li>
<li><a  href='crates-and-modules.html'><b>4.25.</b> クレートとモジュール</a>
</li>
<li><a  href='const-and-static.html'><b>4.26.</b> `const` と `static`</a>
</li>
<li><a  href='attributes.html'><b>4.27.</b> アトリビュート</a>
</li>
<li><a  href='type-aliases.html'><b>4.28.</b> `type` エイリアス</a>
</li>
<li><a  href='casting-between-types.html'><b>4.29.</b> 型間のキャスト</a>
</li>
<li><a  href='associated-types.html'><b>4.30.</b> 関連型</a>
</li>
<li><a  href='unsized-types.html'><b>4.31.</b> サイズ不定型</a>
</li>
<li><a  href='operators-and-overloading.html'><b>4.32.</b> 演算子とオーバーロード</a>
</li>
<li><a  href='deref-coercions.html'><b>4.33.</b> Derefによる型強制</a>
</li>
<li><a  href='macros.html'><b>4.34.</b> マクロ</a>
</li>
<li><a  href='raw-pointers.html'><b>4.35.</b> 生ポインタ</a>
</li>
<li><a  href='unsafe.html'><b>4.36.</b> `unsafe`</a>
</li>
</ul>
</li>
<li><a  href='effective-rust.html'><b>5.</b> Effective Rust</a>
<ul class='section'>
<li><a  href='the-stack-and-the-heap.html'><b>5.1.</b> スタックとヒープ</a>
</li>
<li><a  href='testing.html'><b>5.2.</b> テスト</a>
</li>
<li><a  href='conditional-compilation.html'><b>5.3.</b> 条件付きコンパイル</a>
</li>
<li><a  href='documentation.html'><b>5.4.</b> ドキュメント</a>
</li>
<li><a  href='iterators.html'><b>5.5.</b> イテレータ</a>
</li>
<li><a  href='concurrency.html'><b>5.6.</b> 並行性</a>
</li>
<li><a class='active' href='error-handling.html'><b>5.7.</b> エラーハンドリング</a>
</li>
<li><a  href='choosing-your-guarantees.html'><b>5.8.</b> 保証を選ぶ</a>
</li>
<li><a  href='ffi.html'><b>5.9.</b> FFI</a>
</li>
<li><a  href='borrow-and-asref.html'><b>5.10.</b> BorrowとAsRef</a>
</li>
<li><a  href='release-channels.html'><b>5.11.</b> リリースチャネル</a>
</li>
<li><a  href='using-rust-without-the-standard-library.html'><b>5.12.</b> 標準ライブラリ無しでRustを使う</a>
</li>
</ul>
</li>
<li><a  href='nightly-rust.html'><b>6.</b> Nightly Rust</a>
<ul class='section'>
<li><a  href='compiler-plugins.html'><b>6.1.</b> コンパイラプラグイン</a>
</li>
<li><a  href='inline-assembly.html'><b>6.2.</b> インラインアセンブリ</a>
</li>
<li><a  href='no-stdlib.html'><b>6.3.</b> No stdlib</a>
</li>
<li><a  href='intrinsics.html'><b>6.4.</b> Intrinsic</a>
</li>
<li><a  href='lang-items.html'><b>6.5.</b> Lang Items</a>
</li>
<li><a  href='advanced-linking.html'><b>6.6.</b> 高度なリンキング</a>
</li>
<li><a  href='benchmark-tests.html'><b>6.7.</b> ベンチマークテスト</a>
</li>
<li><a  href='box-syntax-and-patterns.html'><b>6.8.</b> Box構文とパターン</a>
</li>
<li><a  href='slice-patterns.html'><b>6.9.</b> スライスパターン</a>
</li>
<li><a  href='associated-constants.html'><b>6.10.</b> 関連定数</a>
</li>
<li><a  href='custom-allocators.html'><b>6.11.</b> カスタムアロケータ</a>
</li>
</ul>
</li>
<li><a  href='glossary.html'><b>7.</b> 用語集</a>
</li>
<li><a  href='syntax-index.html'><b>8.</b> 構文の索引</a>
</li>
<li><a  href='bibliography.html'><b>9.</b> 関係書目</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">エラーハンドリング</h1>
    <!-- % Error Handling -->

<!-- Like most programming languages, Rust encourages the programmer to handle -->

<!-- errors in a particular way. Generally speaking, error handling is divided into -->

<!-- two broad categories: exceptions and return values. Rust opts for return -->

<!-- values. -->

<p>他のほとんどのプログラミング言語と同様、Rustはプログラマに、ある決まった作法でエラーを扱うことを促します。
一般的にエラーハンドリングは、例外、もしくは、戻り値を使ったものの、大きく2つに分類されます。
Rustでは戻り値を使います。</p>

<!-- In this chapter, we intend to provide a comprehensive treatment of how to deal -->

<!-- with errors in Rust. More than that, we will attempt to introduce error handling -->

<!-- one piece at a time so that you'll come away with a solid working knowledge of -->

<!-- how everything fits together. -->

<p>この章では、Rustでのエラーハンドリングに関わる包括的な扱い方を提示しようと思います。
単にそれだけではなく、エラーハンドリングのやり方を、ひとつひとつ、順番に積み上げていきます。
こうすることで、全体がどう組み合わさっているのかの理解が進み、より実用的な知識が身につくでしょう。</p>

<!-- When done naïvely, error handling in Rust can be verbose and annoying. This -->

<!-- chapter will explore those stumbling blocks and demonstrate how to use the -->

<!-- standard library to make error handling concise and ergonomic. -->

<p>もし素朴なやり方を用いたなら、Rustにおけるエラーハンドリングは、冗長で面倒なものになり得ます。
この章では、エラーを処理する上でどのような課題があるかを吟味し、標準ライブラリを使うと、それがいかにシンプルでエルゴノミック（人間にとって扱いやすいもの）に変わるのかを紹介します。</p>

<!-- # Table of Contents -->

<h1 id='目次' class='section-header'><a href='#目次'>目次</a></h1>
<!-- This chapter is very long, mostly because we start at the very beginning with -->

<!-- sum types and combinators, and try to motivate the way Rust does error handling -->

<!-- incrementally. As such, programmers with experience in other expressive type -->

<!-- systems may want to jump around. -->

<p>この章はとても長くなります。
というのは、直和型(sum type) とコンビネータから始めることで、Restにおけるエラーハンドリングを徐々に改善していくための動機を与えるからです。
このような構成ですので、もしすでに他の表現力豊かな型システムの経験があるプログラマでしたら、あちこち拾い読みしたくなるかもしれません。</p>

<!-- * [The Basics](#the-basics) -->

<!--     * [Unwrapping explained](#unwrapping-explained) -->

<!--     * [The `Option` type](#the-option-type) -->

<!--         * [Composing `Option<T>` values](#composing-optiont-values) -->

<!--     * [The `Result` type](#the-result-type) -->

<!--         * [Parsing integers](#parsing-integers) -->

<!--         * [The `Result` type alias idiom](#the-result-type-alias-idiom) -->

<!--     * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isnt-evil) -->

<!-- * [Working with multiple error types](#working-with-multiple-error-types) -->

<!--     * [Composing `Option` and `Result`](#composing-option-and-result) -->

<!--     * [The limits of combinators](#the-limits-of-combinators) -->

<!--     * [Early returns](#early-returns) -->

<!--     * [The `try!` macro](#the-try-macro) -->

<!--     * [Defining your own error type](#defining-your-own-error-type) -->

<!-- * [Standard library traits used for error handling](#standard-library-traits-used-for-error-handling) -->

<!--     * [The `Error` trait](#the-error-trait) -->

<!--     * [The `From` trait](#the-from-trait) -->

<!--     * [The real `try!` macro](#the-real-try-macro) -->

<!--     * [Composing custom error types](#composing-custom-error-types) -->

<!--     * [Advice for library writers](#advice-for-library-writers) -->

<!-- * [Case study: A program to read population data](#case-study-a-program-to-read-population-data) -->

<!--     * [Initial setup](#initial-setup) -->

<!--     * [Argument parsing](#argument-parsing) -->

<!--     * [Writing the logic](#writing-the-logic) -->

<!--     * [Error handling with `Box<Error>`](#error-handling-with-boxerror) -->

<!--     * [Reading from stdin](#reading-from-stdin) -->

<!--     * [Error handling with a custom type](#error-handling-with-a-custom-type) -->

<!--     * [Adding functionality](#adding-functionality) -->

<!--  [The short story](#the-short-story) -->

<ul>
<li><a href="#%E5%9F%BA%E7%A4%8E">基礎</a>

<ul>
<li><a href="#%E3%82%A2%E3%83%B3%E3%83%A9%E3%83%83%E3%83%97unwrap-%E3%81%A8%E3%81%AF">アンラップ(unwrap) とは</a></li>
<li><a href="#option-%E5%9E%8B"><code>Option</code> 型</a>

<ul>
<li><a href="#optiont-%E5%80%A4%E3%82%92%E5%90%88%E6%88%90%E3%81%99%E3%82%8B"><code>Option&lt;T&gt;</code> 値を合成する</a></li>
</ul></li>
<li><a href="#result-%E5%9E%8B"><code>Result</code> 型</a>

<ul>
<li><a href="#%E6%95%B4%E6%95%B0%E3%82%92%E3%83%91%E3%83%BC%E3%82%B9%E3%81%99%E3%82%8B">整数をパースする</a></li>
<li><a href="#result-%E5%9E%8B%E3%82%A8%E3%82%A4%E3%83%AA%E3%82%A2%E3%82%B9%E3%82%92%E7%94%A8%E3%81%84%E3%81%9F%E3%82%A4%E3%83%87%E3%82%A3%E3%82%AA%E3%83%A0"><code>Result</code> 型エイリアスを用いたイディオム</a></li>
</ul></li>
<li><a href="#%E5%B0%8F%E4%BC%91%E6%AD%A2%E3%82%A2%E3%83%B3%E3%83%A9%E3%83%83%E3%83%97%E3%81%AF%E6%82%AA%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84">小休止：アンラップは悪ではない</a></li>
</ul></li>
<li><a href="#working-with-multiple-error-types">複数のエラー型を扱う</a>

<ul>
<li><a href="#composing-option-and-result"><code>Option</code> と <code>Result</code> を合成する</a></li>
<li><a href="#the-limits-of-combinators">コンビネータの限界</a></li>
<li><a href="#early-returns">早期のリターン</a></li>
<li><a href="#the-try-macro"><code>try!</code> マクロ</a></li>
<li><a href="#defining-your-own-error-type">独自のエラー型を定義する</a></li>
</ul></li>
<li><a href="#standard-library-traits-used-for-error-handling">標準ライブラリのトレイトによるエラー処理</a>

<ul>
<li><a href="#the-error-trait"><code>Error</code> トレイト</a></li>
<li><a href="#the-from-trait"><code>From</code> トレイト</a></li>
<li><a href="#the-real-try-macro">本当の <code>try!</code> マクロ</a></li>
<li><a href="#composing-custom-error-types">独自のエラー型を合成する</a></li>
<li><a href="#advice-for-library-writers">ライブラリ作者たちへのアドバイス</a></li>
</ul></li>
<li><a href="#case-study-a-program-to-read-population-data">ケーススタディ：人口データを読み込むプログラム</a>

<ul>
<li><a href="#initial-setup">最初のセットアップ</a></li>
<li><a href="#argument-parsing">引数のパース</a></li>
<li><a href="#writing-the-logic">ロジックを書く</a></li>
<li><a href="#error-handling-with-boxerror"><code>Box&lt;Error&gt;</code> によるエラー処理</a></li>
<li><a href="#reading-from-stdin">標準入力から読み込む</a></li>
<li><a href="#error-handling-with-a-custom-type">独自のエラー型によるエラー処理</a></li>
<li><a href="#adding-functionality">機能を追加する</a></li>
</ul></li>
<li><a href="#the-short-story">簡単な説明（まとめ）</a></li>
</ul>

<!-- # The Basics -->

<h1 id='基礎' class='section-header'><a href='#基礎'>基礎</a></h1>
<!-- You can think of error handling as using *case analysis* to determine whether -->

<!-- a computation was successful or not. As you will see, the key to ergonomic error -->

<!-- handling is reducing the amount of explicit case analysis the programmer has to -->

<!-- do while keeping code composable. -->

<p>エラーハンドリングとは、ある処理が成功したかどうかを <em>ケース分析</em> に基づいて判断するものだと考えられます。
これから見ていくように、エラーハンドリングをエルゴノミックにするために重要なのは、プログラマがコードを合成可能(composable) に保ったまま、明示的なケース分析の回数を、いかに減らしていくかということです。</p>

<!-- Keeping code composable is important, because without that requirement, we -->

<!-- could [`panic`](../std/macro.panic!.html) whenever we -->

<!-- come across something unexpected. (`panic` causes the current task to unwind, -->

<!-- and in most cases, the entire program aborts.) Here's an example: -->

<p>コードを合成可能に保つのは重要です。
なぜなら、もしこの要求がなかったら、想定外のことが起こる度に <a href="../std/macro.panic!.html"><code>panic</code></a> することを選ぶかもしれないからです。
（<code>panic</code> は現タスクを巻き戻し(unwind) して、ほとんどの場合、プログラム全体をアボートします。）</p>
<span class='rusttest'>// Guess a number between 1 and 10.
// If it matches the number we had in mind, return true. Else, return false.
// 1から10までの数字を予想します。
// もし予想した数字に一致したらtrueを返し、そうでなけれは、falseを返します。
fn guess(n: i32) -&gt; bool {
    if n &lt; 1 || n &gt; 10 {
        panic!(&quot;Invalid number: {}&quot;, n);
    }
    n == 5
}

fn main() {
    guess(11);
}
</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 1から10までの数字を予想します。</span>
<span class='comment'>// もし予想した数字に一致したらtrueを返し、そうでなけれは、falseを返します。</span>
<span class='kw'>fn</span> <span class='ident'>guess</span>(<span class='ident'>n</span>: <span class='ident'>i32</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='kw'>if</span> <span class='ident'>n</span> <span class='op'>&lt;</span> <span class='number'>1</span> <span class='op'>||</span> <span class='ident'>n</span> <span class='op'>&gt;</span> <span class='number'>10</span> {
        <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Invalid number: {}&quot;</span>, <span class='ident'>n</span>);
    }
    <span class='ident'>n</span> <span class='op'>==</span> <span class='number'>5</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='ident'>guess</span>(<span class='number'>11</span>);
}</pre>

<blockquote>
<p>訳注：文言の意味は</p>

<ul>
<li>Invalid number: {}：無効な数字です: {}</li>
</ul>

<p>ですが、エディタの設定などによっては、ソースコード中の
コメント以外の場所に日本語を使うとコンパイルできないことがあるので、
英文のままにしてあります。</p>
</blockquote>

<!-- If you try running this code, the program will crash with a message like this: -->

<p>このコードを実行すると、プログラムがクラッシュして、以下のようなメッセージが表示されます。</p>

<pre><code class="language-text">thread &#39;&lt;main&gt;&#39; panicked at &#39;Invalid number: 11&#39;, src/bin/panic-simple.rs:5
</code></pre>

<!-- Here's another example that is slightly less contrived. A program that accepts -->

<!-- an integer as an argument, doubles it and prints it. -->

<p>次は、もう少し自然な例です。
このプログラムは引数として整数を受け取り、2倍した後に表示します。</p>

<p><span id="code-unwrap-double"></span></p>
<span class='rusttest'>use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // エラー1
    let n: i32 = arg.parse().unwrap(); // エラー2
    println!(&quot;{}&quot;, 2 * n);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>env</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>argv</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>();
    <span class='kw'>let</span> <span class='ident'>arg</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>argv</span>.<span class='ident'>nth</span>(<span class='number'>1</span>).<span class='ident'>unwrap</span>(); <span class='comment'>// エラー1</span>
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>arg</span>.<span class='ident'>parse</span>().<span class='ident'>unwrap</span>(); <span class='comment'>// エラー2</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>);
}</pre>

<!-- If you give this program zero arguments (error 1) or if the first argument -->

<!-- isn't an integer (error 2), the program will panic just like in the first -->

<!-- example. -->

<p>もし、このプログラムに引数を与えなかったら（エラー1）、あるいは、最初の引数が整数でなかったら（エラー2）、このプログラムは、最初の例と同じようにパニックするでしょう。</p>

<!-- You can think of this style of error handling as similar to a bull running -->

<!-- through a china shop. The bull will get to where it wants to go, but it will -->

<!-- trample everything in the process. -->

<p>このようなスタイルのエラーハンドリングは、まるで、陶器店の中を駆け抜ける雄牛のようなものです。
雄牛は自分の行きたいところへたどり着くでしょう。
でも彼は、途中にある、あらゆるものを蹴散らしてしまいます。</p>

<!-- ## Unwrapping explained -->

<h2 id='アンラップunwrap-とは' class='section-header'><a href='#アンラップunwrap-とは'>アンラップ(unwrap) とは</a></h2>
<!-- In the previous example, we claimed -->

<!-- that the program would simply panic if it reached one of the two error -->

<!-- conditions, yet, the program does not include an explicit call to `panic` like -->

<!-- the first example. This is because the -->

<!-- panic is embedded in the calls to `unwrap`. -->

<p>先ほどの例で、プログラムが2つのエラー条件のいずれかを満たした時に、パニックすると言いました。
でもこのプログラムは、最初の例とは違って明示的に <code>panic</code> を呼び出してはいません。
実はパニックは <code>unwrap</code> の呼び出しの中に埋め込まれているのです。</p>

<!-- To “unwrap” something in Rust is to say, “Give me the result of the -->

<!-- computation, and if there was an error, just panic and stop the program.” -->

<!-- It would be better if we just showed the code for unwrapping because it is so -->

<!-- simple, but to do that, we will first need to explore the `Option` and `Result` -->

<!-- types. Both of these types have a method called `unwrap` defined on them. -->

<p>Rustでなにかを「アンラップする」時、こう言っているのと同じです。
「計算結果を取り出しなさい。もしエラーになっていたのなら、パニックを起こしてプログラムを終了させなさい。」
アンラップのコードはとてもシンプルなので、多分、それを見せたほうが早いでしょう。
でもそのためには、まず <code>Option</code> と <code>Result</code> 型について調べる必要があります。
どちらの型にも <code>unwrap</code> という名前のメソッドが定義されています。</p>

<!-- ### The `Option` type -->

<h3 id='option-型' class='section-header'><a href='#option-型'><code>Option</code> 型</a></h3>
<!-- The `Option` type is [defined in the standard library][5]: -->

<p><code>Option</code> 型は <a href="../std/option/enum.Option.html">標準ライブラリで定義されています</a>：</p>
<span class='rusttest'>fn main() {
    enum Option&lt;T&gt; {
        None,
        Some(T),
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>None</span>,
    <span class='prelude-val'>Some</span>(<span class='ident'>T</span>),
}</pre>

<!-- The `Option` type is a way to use Rust's type system to express the -->

<!-- *possibility of absence*. Encoding the possibility of absence into the type -->

<!-- system is an important concept because it will cause the compiler to force the -->

<!-- programmer to handle that absence. Let's take a look at an example that tries -->

<!-- to find a character in a string: -->

<p><code>Option</code> 型は、Rustの型システムを使って <em>不在の可能性</em> を示すためのものです。
不在の可能性を型システムにエンコードすることは、重要なコンセプトです。
なぜなら、その不在に対処することを、コンパイラがプログラマに強制させるからです。
では、文字列から文字を検索する例を見てみましょう。</p>

<p><span id="code-option-ex-string-find"></span></p>
<span class='rusttest'>fn main() {
    // Searches `haystack` for the Unicode character `needle`. If one is found, the
    // byte offset of the character is returned. Otherwise, `None` is returned.
    // `haystack`（干し草の山）からUnicode文字 `needle`（縫い針）を検索します。
    // もし見つかったら、文字のバイトオフセットを返します。見つからなければ、`None` を
    // 返します。
    fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
        for (offset, c) in haystack.char_indices() {
            if c == needle {
                return Some(offset);
            }
        }
        None
    }
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// `haystack`（干し草の山）からUnicode文字 `needle`（縫い針）を検索します。</span>
<span class='comment'>// もし見つかったら、文字のバイトオフセットを返します。見つからなければ、`None` を</span>
<span class='comment'>// 返します。</span>
<span class='kw'>fn</span> <span class='ident'>find</span>(<span class='ident'>haystack</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>needle</span>: <span class='ident'>char</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>usize</span><span class='op'>&gt;</span> {
    <span class='kw'>for</span> (<span class='ident'>offset</span>, <span class='ident'>c</span>) <span class='kw'>in</span> <span class='ident'>haystack</span>.<span class='ident'>char_indices</span>() {
        <span class='kw'>if</span> <span class='ident'>c</span> <span class='op'>==</span> <span class='ident'>needle</span> {
            <span class='kw'>return</span> <span class='prelude-val'>Some</span>(<span class='ident'>offset</span>);
        }
    }
    <span class='prelude-val'>None</span>
}</pre>

<!-- Notice that when this function finds a matching character, it doesn't just -->

<!-- return the `offset`. Instead, it returns `Some(offset)`. `Some` is a variant or -->

<!-- a *value constructor* for the `Option` type. You can think of it as a function -->

<!-- with the type `fn<T>(value: T) -> Option<T>`. Correspondingly, `None` is also a -->

<!-- value constructor, except it has no arguments. You can think of `None` as a -->

<!-- function with the type `fn<T>() -> Option<T>`. -->

<p>この関数がマッチする文字を見つけた時、単に <code>offset</code> を返すだけではないことに注目してください。
その代わりに <code>Some(offset)</code> を返します。
<code>Some</code> は <code>Option</code> 型の <em>値コンストラクタ</em> の一つです。
これは <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code> という型の関数だと考えることもできます。
これに対応して <code>None</code> もまた値コンストラクタですが、こちらには引数がありません。
<code>None</code> は <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code> という型の関数だと考えることもできます。</p>

<!-- This might seem like much ado about nothing, but this is only half of the -->

<!-- story. The other half is *using* the `find` function we've written. Let's try -->

<!-- to use it to find the extension in a file name. -->

<p>何もないことを表すのに、ずいぶん大げさだと感じるかもしれません。
でもこれはまだ、話の半分に過ぎません。
残りの半分は、いま書いた <code>find</code> 関数を <em>使う</em> 場面です。
これを使って、ファイル名から拡張子を見つけてみましょう。</p>
<span class='rusttest'>fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
fn main() {
    let file_name = &quot;foobar.rs&quot;;
    match find(file_name, &#39;.&#39;) {
        None =&gt; println!(&quot;No file extension found.&quot;),
        Some(i) =&gt; println!(&quot;File extension: {}&quot;, &amp;file_name[i+1..]),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>file_name</span> <span class='op'>=</span> <span class='string'>&quot;foobar.rs&quot;</span>;
    <span class='kw'>match</span> <span class='ident'>find</span>(<span class='ident'>file_name</span>, <span class='string'>&#39;.&#39;</span>) {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;No file extension found.&quot;</span>),
        <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;File extension: {}&quot;</span>, <span class='kw-2'>&amp;</span><span class='ident'>file_name</span>[<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>..]),
    }
}</pre>

<blockquote>
<p>訳注：</p>

<ul>
<li>No file extension found：ファイル拡張子は見つかりませんでした</li>
<li>File extension: {}：ファイル拡張子：{}</li>
</ul>
</blockquote>

<!-- This code uses [pattern matching][1] to do *case -->

<!-- analysis* on the `Option<usize>` returned by the `find` function. In fact, case -->

<!-- analysis is the only way to get at the value stored inside an `Option<T>`. This -->

<!-- means that you, as the programmer, must handle the case when an `Option<T>` is -->

<!-- `None` instead of `Some(t)`. -->

<p>このコードは <code>find</code> 関数が返した <code>Option&lt;usize&gt;</code> の <em>ケース分析</em> に、 <a href="../book/patterns.html">パターンマッチ</a> を使っています。
実のところ、ケース分析が、<code>Option&lt;T&gt;</code> に格納された値を取り出すための唯一の方法なのです。
これは、<code>Option&lt;T&gt;</code> が <code>Some(t)</code> ではなく <code>None</code> だった時、プログラマであるあなたが、このケースに対処しなければならないことを意味します。</p>

<!-- But wait, what about `unwrap`,which we used [`previously`](#code-unwrap-double)? -->

<!-- There was no case analysis there! Instead, the case analysis was put inside the -->

<!-- `unwrap` method for you. You could define it yourself if you want: -->

<p>でも、ちょっと待ってください。 <a href="#code-unwrap-double">さっき</a> 使った <code>unwrap</code> はどうだったでしょうか？
ケース分析はどこにもありませんでした！
実はケース分析は <code>unwrap</code> メソッドの中に埋め込まれていたのです。
もし望むなら、このように自分で定義することもできます：</p>

<p><span id="code-option-def-unwrap"></span></p>
<span class='rusttest'>fn main() {
    enum Option&lt;T&gt; {
        None,
        Some(T),
    }
    
    impl&lt;T&gt; Option&lt;T&gt; {
        fn unwrap(self) -&gt; T {
            match self {
                Option::Some(val) =&gt; val,
                Option::None =&gt;
                  panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
            }
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>None</span>,
    <span class='prelude-val'>Some</span>(<span class='ident'>T</span>),
}

<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>unwrap</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
        <span class='kw'>match</span> <span class='self'>self</span> {
            <span class='prelude-ty'>Option</span>::<span class='prelude-val'>Some</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
            <span class='prelude-ty'>Option</span>::<span class='prelude-val'>None</span> <span class='op'>=&gt;</span>
              <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;called `Option::unwrap()` on a `None` value&quot;</span>),
        }
    }
}</pre>

<blockquote>
<p>訳注：</p>

<p>called <code>Option::unwrap()</code> on a <code>None</code> value：<br/>
<code>None</code> な値に対して <code>Option:unwpal()</code> が呼ばれました</p>
</blockquote>

<!-- The `unwrap` method *abstracts away the case analysis*. This is precisely the thing -->

<!-- that makes `unwrap` ergonomic to use. Unfortunately, that `panic!` means that -->

<!-- `unwrap` is not composable: it is the bull in the china shop. -->

<p><code>unwrap</code> メソッドは <em>ケース分析を抽象化します</em> 。このことは確かに <code>unwrap</code> をエルゴノミックにしています。
しかし残念なことに、そこにある <code>panic!</code> が意味するものは、<code>unwrap</code> が合成可能ではない、つまり、陶器店の中の雄牛だということです。</p>

<!--- ### Composing `Option<T>` values -->

<h3 id='optiont-値を合成する' class='section-header'><a href='#optiont-値を合成する'><code>Option&lt;T&gt;</code> 値を合成する</a></h3>
<!-- In an [example from before](#code-option-ex-string-find), -->

<!-- we saw how to use `find` to discover the extension in a file name. Of course, -->

<!-- not all file names have a `.` in them, so it's possible that the file name has -->

<!-- no extension. This *possibility of absence* is encoded into the types using -->

<!-- `Option<T>`. In other words, the compiler will force us to address the -->

<!-- possibility that an extension does not exist. In our case, we just print out a -->

<!-- message saying as such. -->

<p><a href="#code-option-ex-string-find">先ほどの例</a> では、ファイル名から拡張子を見つけるために <code>find</code> をどのように使うかを見ました。
当然ながら全てのファイル名に <code>.</code> があるわけではなく、拡張子のないファイル名もあり得ます。
このような <em>不在の可能性</em> は <code>Option&lt;T&gt;</code> を使うことによって、型の中にエンコードされています。
すなわち、コンパイラは、拡張子が存在しない可能性に対処することを、私たちに強制してくるわけです。
今回は単に、そうなったことを告げるメッセージを表示するようにしました。</p>

<!-- Getting the extension of a file name is a pretty common operation, so it makes -->

<!-- sense to put it into a function: -->

<p>ファイル名から拡張子を取り出すことは一般的な操作ですので、それを関数にすることは理にかなっています。</p>
<span class='rusttest'>fn main() {
    fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
    // Returns the extension of the given file name, where the extension is defined
    // as all characters proceeding the first `.`.
    // If `file_name` has no `.`, then `None` is returned.
    // 与えられたファイル名の拡張子を返す。拡張子の定義は、最初の
    // `.` に続く、全ての文字である。
    // もし `file_name` に `.` がなければ、`None` が返される。
    fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
        match find(file_name, &#39;.&#39;) {
            None =&gt; None,
            Some(i) =&gt; Some(&amp;file_name[i+1..]),
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 与えられたファイル名の拡張子を返す。拡張子の定義は、最初の</span>
<span class='comment'>// `.` に続く、全ての文字である。</span>
<span class='comment'>// もし `file_name` に `.` がなければ、`None` が返される。</span>
<span class='kw'>fn</span> <span class='ident'>extension_explicit</span>(<span class='ident'>file_name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>find</span>(<span class='ident'>file_name</span>, <span class='string'>&#39;.&#39;</span>) {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>i</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='kw-2'>&amp;</span><span class='ident'>file_name</span>[<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>..]),
    }
}</pre>

<!-- (pro-tip: don't use this code. Use the -->

<!-- [`extension`](../std/path/struct.Path.html#method.extension) -->

<!-- method in the standard library instead.) -->

<p>（プロ向けのヒント：このコードは使わず、代わりに標準ライブラリの
<a href="../std/path/struct.Path.html#method.extension"><code>extension</code></a>
メソッドを使ってください）</p>

<!-- The code stays simple, but the important thing to notice is that the type of -->

<!-- `find` forces us to consider the possibility of absence. This is a good thing -->

<!-- because it means the compiler won't let us accidentally forget about the case -->

<!-- where a file name doesn't have an extension. On the other hand, doing explicit -->

<!-- case analysis like we've done in `extension_explicit` every time can get a bit -->

<!-- tiresome. -->

<p>このコードはいたってシンプルですが、ひとつだけ注目して欲しいのは、<code>find</code> の型が不在の可能性について考慮することを強制していることです。
これは良いことです。なぜなら、コンパイラが私たちに、ファイル名が拡張子を持たないケースを、うっかり忘れないようにしてくれるからです。
しかし一方で、 <code>extension_explicit</code> でしたような明示的なケース分析を毎回続けるのは、なかなか面倒です。</p>

<!-- In fact, the case analysis in `extension_explicit` follows a very common -->

<!-- pattern: *map* a function on to the value inside of an `Option<T>`, unless the -->

<!-- option is `None`, in which case, just return `None`. -->

<p>実は <code>extension_explicit</code> でのケース分析は、ごく一般的なパターンである、<code>Option&lt;T&gt;</code> への <em>map</em> の適用に当てはめられます。
これは、もしオプションが <code>None</code> なら <code>None</code> を返し、そうでなけれは、オプションの中の値に関数を適用する、というパターンです。</p>

<!-- Rust has parametric polymorphism, so it is very easy to define a combinator -->

<!-- that abstracts this pattern: -->

<p>Rustはパラメトリック多相をサポートしていますので、このパターンを抽象化するためのコンビネータが簡単に定義できます：</p>

<p><span id="code-option-map"></span></p>
<span class='rusttest'>fn main() {
    fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {
        match option {
            None =&gt; None,
            Some(value) =&gt; Some(f(value)),
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>map</span><span class='op'>&lt;</span><span class='ident'>F</span>, <span class='ident'>T</span>, <span class='ident'>A</span><span class='op'>&gt;</span>(<span class='ident'>option</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>FnOnce</span>(<span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>A</span> {
    <span class='kw'>match</span> <span class='ident'>option</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>value</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>f</span>(<span class='ident'>value</span>)),
    }
}</pre>

<!-- Indeed, `map` is [defined as a method][2] on `Option<T>` in the standard library. -->

<p>もちろん <code>map</code> は、標準のライブラリの <code>Option&lt;T&gt;</code> で <a href="../std/option/enum.Option.html#method.map">メソッドとして定義されています</a>。</p>

<!-- Armed with our new combinator, we can rewrite our `extension_explicit` method -->

<!-- to get rid of the case analysis: -->

<p>新しいコンビネータを手に入れましたので、 <code>extension_explicit</code> メソッドを書き直して、ケース分析を省きましょう：</p>
<span class='rusttest'>fn main() {
    fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
    // Returns the extension of the given file name, where the extension is defined
    // as all characters proceeding the first `.`.
    // If `file_name` has no `.`, then `None` is returned.
    // 与えられたファイル名の拡張子を返す。拡張子の定義は、最初の
    // `.` に続く、全ての文字である。
    // もし `file_name` に `.` がなければ、`None` が返される。
    fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
        find(file_name, &#39;.&#39;).map(|i| &amp;file_name[i+1..])
    }
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// 与えられたファイル名の拡張子を返す。拡張子の定義は、最初の</span>
<span class='comment'>// `.` に続く、全ての文字である。</span>
<span class='comment'>// もし `file_name` に `.` がなければ、`None` が返される。</span>
<span class='kw'>fn</span> <span class='ident'>extension</span>(<span class='ident'>file_name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='ident'>find</span>(<span class='ident'>file_name</span>, <span class='string'>&#39;.&#39;</span>).<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>i</span><span class='op'>|</span> <span class='kw-2'>&amp;</span><span class='ident'>file_name</span>[<span class='ident'>i</span><span class='op'>+</span><span class='number'>1</span>..])
}</pre>

<!-- One other pattern we commonly find is assigning a default value to the case -->

<!-- when an `Option` value is `None`. For example, maybe your program assumes that -->

<!-- the extension of a file is `rs` even if none is present. As you might imagine, -->

<!-- the case analysis for this is not specific to file extensions - it can work -->

<!-- with any `Option<T>`: -->

<p>もう一つの共通のパターンは、<code>Option</code> の値が <code>None</code> だった時のデフォルト値を与えることです。
例えばファイルの拡張子がない時は、それを <code>rs</code> とみなすようなプログラムを書きたくなるかもしれません。
ご想像の通り、このようなケース分析はファイルの拡張子に特有のものではありません。
どんな <code>Option&lt;T&gt;</code> でも使えるでしょう：</p>
<span class='rusttest'>fn main() {
    fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {
        match option {
            None =&gt; default,
            Some(value) =&gt; value,
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>unwrap_or</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>(<span class='ident'>option</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>default</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
    <span class='kw'>match</span> <span class='ident'>option</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='ident'>default</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>value</span>) <span class='op'>=&gt;</span> <span class='ident'>value</span>,
    }
}</pre>

<!-- The trick here is that the default value must have the same type as the value -->

<!-- that might be inside the `Option<T>`. Using it is dead simple in our case: -->

<p>ここでの仕掛けは、<code>Option&lt;T&gt;</code> に入れる値と同じ型になるよう、デフォルト値の型を制限していることです。
これを使うのは、すごく簡単です：</p>
<span class='rusttest'>fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}

fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    find(file_name, &#39;.&#39;).map(|i| &amp;file_name[i+1..])
}
fn main() {
    assert_eq!(extension(&quot;foobar.csv&quot;).unwrap_or(&quot;rs&quot;), &quot;csv&quot;);
    assert_eq!(extension(&quot;foobar&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>extension</span>(<span class='string'>&quot;foobar.csv&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='string'>&quot;rs&quot;</span>), <span class='string'>&quot;csv&quot;</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>extension</span>(<span class='string'>&quot;foobar&quot;</span>).<span class='ident'>unwrap_or</span>(<span class='string'>&quot;rs&quot;</span>), <span class='string'>&quot;rs&quot;</span>);
}</pre>

<!-- (Note that `unwrap_or` is [defined as a method][3] on `Option<T>` in the -->

<!-- standard library, so we use that here instead of the free-standing function we -->

<!-- defined above. Don't forget to check out the more general [`unwrap_or_else`][4] -->

<!-- method.) -->

<p>（<code>unwrap_or</code> は、標準のライブラリの <code>Option&lt;T&gt;</code> で、 <a href="../std/option/enum.Option.html#method.unwrap_or">メソッドとして定義されています</a> ので、いま定義したフリースタンディングな関数の代わりに、そちらを使いましょう。）</p>

<!-- There is one more combinator that we think is worth paying special attention to: -->

<!-- `and_then`. It makes it easy to compose distinct computations that admit the -->

<!-- *possibility of absence*. For example, much of the code in this section is -->

<!-- about finding an extension given a file name. In order to do this, you first -->

<!-- need the file name which is typically extracted from a file *path*. While most -->

<!-- file paths have a file name, not *all* of them do. For example, `.`, `..` or -->

<!-- `/`. -->

<p>もうひとつ特筆すべきコンビネータがあります。それは <code>and_then</code> です。これを使うと <em>不在の可能性</em> を考慮しながら、別々の処理を簡単に組み合わせることができます。
例えば、この節のほとんどのコードは、与えられたファイル名について拡張子を見つけだします。
そのためには、まずファイル <em>パス</em> から取り出したファイル名が必要です。
大抵のパスにはファイル名がありますが、 <em>全て</em> がというわけではありません。
例えば <code>.</code>, <code>..</code>, <code>/</code> などは例外です。</p>

<!-- So, we are tasked with the challenge of finding an extension given a file -->

<!-- *path*. Let's start with explicit case analysis: -->

<p>つまり、与えられたファイル <em>パス</em> から拡張子を見つけ出せるか、トライしなければなりません。
まず明示的なケース分析から始めましょう：</p>
<span class='rusttest'>fn main() {
    fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
    fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
        match file_name(file_path) {
            None =&gt; None,
            Some(name) =&gt; match extension(name) {
                None =&gt; None,
                Some(ext) =&gt; Some(ext),
            }
        }
    }
    
    fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
     // implementation elided
      // 実装は省略
      unimplemented!()
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>file_path_ext_explicit</span>(<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>file_name</span>(<span class='ident'>file_path</span>) {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>name</span>) <span class='op'>=&gt;</span> <span class='kw'>match</span> <span class='ident'>extension</span>(<span class='ident'>name</span>) {
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
            <span class='prelude-val'>Some</span>(<span class='ident'>ext</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>ext</span>),
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>file_name</span>(<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
  <span class='comment'>// 実装は省略</span>
  <span class='macro'>unimplemented</span><span class='macro'>!</span>()
}</pre>

<!-- You might think that we could just use the `map` combinator to reduce the case -->

<!-- analysis, but its type doesn't quite fit. Namely, `map` takes a function that -->

<!-- does something only with the inner value. The result of that function is then -->

<!-- *always* [rewrapped with `Some`](#code-option-map). Instead, we need something -->

<!-- like `map`, but which allows the caller to return another `Option`. Its generic -->

<!-- implementation is even simpler than `map`: -->

<p>ケース分析を減らすために単に <code>map</code> コンビネータを使えばいいと思うかもしれませんが、型にうまく適合しません。
なぜなら <code>map</code> が引数にとる関数は、中の値だけに適用されるからです。
そして関数が返した値は <em>必ず</em> <a href="#code-option-map"><code>Some</code> でラップされ直します</a> 。
つまりこの代わりに、 <code>map</code> に似ていながら、呼び出し元が別の <code>Option</code> を返せるしくみが必要です。
これの汎用的な実装は <code>map</code> よりもシンプルです：</p>
<span class='rusttest'>fn main() {
    fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;
            where F: FnOnce(T) -&gt; Option&lt;A&gt; {
        match option {
            None =&gt; None,
            Some(value) =&gt; f(value),
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>and_then</span><span class='op'>&lt;</span><span class='ident'>F</span>, <span class='ident'>T</span>, <span class='ident'>A</span><span class='op'>&gt;</span>(<span class='ident'>option</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>f</span>: <span class='ident'>F</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span>
        <span class='kw'>where</span> <span class='ident'>F</span>: <span class='ident'>FnOnce</span>(<span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>A</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>option</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>None</span>,
        <span class='prelude-val'>Some</span>(<span class='ident'>value</span>) <span class='op'>=&gt;</span> <span class='ident'>f</span>(<span class='ident'>value</span>),
    }
}</pre>

<!-- Now we can rewrite our `file_path_ext` function without explicit case analysis: -->

<p>では、明示的なケース分析を省くように、 <code>file_path_ext</code> を書き直しましょう：</p>
<span class='rusttest'>fn main() {
    fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
    fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
    fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
        file_name(file_path).and_then(extension)
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>file_path_ext</span>(<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>str</span><span class='op'>&gt;</span> {
    <span class='ident'>file_name</span>(<span class='ident'>file_path</span>).<span class='ident'>and_then</span>(<span class='ident'>extension</span>)
}</pre>

<!-- The `Option` type has many other combinators [defined in the standardy
<!-- library][5]. It is a good idea to skim this list and familiarize -->

<!-- yourself with what's available—they can often reduce case analysis -->

<!-- for you. Familiarizing yourself with these combinators will pay -->

<!-- dividends because many of them are also defined (with similar -->

<!-- semantics) for `Result`, which we will talk about next. -->

<p><code>Option</code> 型には、他にもたくさんのコンビネータが <a href="../std/option/enum.Option.html">標準ライブラリで定義されています</a> 。
それらの一覧をざっと眺めて、なにがあるか知っておくといいでしょう。
大抵の場合、ケース分析を減らすのに役立ちます。
それらのコンビネータに慣れるための努力は、すぐに報われるでしょう。
なぜなら、そのほとんどは次に話す <code>Result</code> 型でも、（よく似たセマンティクスで）定義されているからです。</p>

<!-- Combinators make using types like `Option` ergonomic because they reduce -->

<!-- explicit case analysis. They are also composable because they permit the caller -->

<!-- to handle the possibility of absence in their own way. Methods like `unwrap` -->

<!-- remove choices because they will panic if `Option<T>` is `None`. -->

<p>コンビネータは明示的なケース分析を減らしてくれるので、 <code>Option</code> のような型をエルゴノミックにします。
またこれらは <em>不在の可能性</em> を、呼び出し元がそれに合った方法で扱えるようにするので、合成可能だといえます。
<code>unwrap</code> のようなメソッドは、 <code>Option&lt;T&gt;</code> が <code>None</code> の時にパニックを起こすので、このような選択の機会を与えません。</p>

<!-- ## The `Result` type -->

<h2 id='result-型' class='section-header'><a href='#result-型'><code>Result</code> 型</a></h2>
<!-- The `Result` type is also -->

<!-- [defined in the standard library][6]: -->

<p><code>Result</code> 型も <a href="../std/result/">標準ライブラリで定義されています</a> 。</p>

<p><span id="code-result-def"></span></p>
<span class='rusttest'>fn main() {
    enum Result&lt;T, E&gt; {
        Ok(T),
        Err(E),
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>enum</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span> {
    <span class='prelude-val'>Ok</span>(<span class='ident'>T</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>E</span>),
}</pre>

<!-- The `Result` type is a richer version of `Option`. Instead of expressing the -->

<!-- possibility of *absence* like `Option` does, `Result` expresses the possibility -->

<!-- of *error*. Usually, the *error* is used to explain why the execution of some -->

<!-- computation failed. This is a strictly more general form of `Option`. Consider -->

<!-- the following type alias, which is semantically equivalent to the real -->

<!-- `Option<T>` in every way: -->

<p><code>Result</code> 型は <code>Option</code> 型の豪華版です。
<code>Option</code> のように <em>不在</em> の可能性を示す代わりに、<code>Result</code> は <em>エラー</em> になる可能性を示します。
通常 <em>エラー</em> は、なぜ処理が実行に失敗したのかを説明するために用いられます。
これは厳密には <code>Option</code> をさらに一般化した形式だといえます。
以下のような型エイリアスがあるとしましょう。
これは全てにおいて、本物の <code>Option&lt;T&gt;</code> と等しいセマンティクスを持ちます。</p>
<span class='rusttest'>fn main() {
    type Option&lt;T&gt; = Result&lt;T, ()&gt;;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>type</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, ()<span class='op'>&gt;</span>;</pre>

<!-- This fixes the second type parameter of `Result` to always be `()` (pronounced -->

<!-- “unit” or “empty tuple”). Exactly one value inhabits the `()` type: `()`. (Yup, -->

<!-- the type and value level terms have the same notation!) -->

<p>これは <code>Result</code> の2番目の型パラメータを <code>()</code> （「ユニット」または「空タプル」と発音します）に固定したものです。
<code>()</code> 型のただ一つの値は <code>()</code> です。
（そうなんです。型レベルと値レベルの項が、全く同じ表記法を持ちます!）</p>

<!-- The `Result` type is a way of representing one of two possible outcomes in a -->

<!-- computation. By convention, one outcome is meant to be expected or “`Ok`” while -->

<!-- the other outcome is meant to be unexpected or “`Err`”. -->

<p><code>Result</code> 型は、処理の結果がとりうる2つの可能性のうち、1つを表すための方法です。
慣例に従い、一方が期待されている結果、つまり「<code>Ok</code>」となり、もう一方が予想外の結果、つまり「<code>Err</code>」になります。</p>

<!-- Just like `Option`, the `Result` type also has an -->

<!-- [`unwrap` method -->

<!-- defined][7] -->

<!-- in the standard library. Let's define it: -->

<p><code>Option</code> と全く同じように、<code>Result</code> 型も標準ライブラリで <a href="../std/result/enum.Result.html#method.unwrap"><code>unwrap</code> メソッドが定義されています</a> 。
定義してみましょう：</p>
<span class='rusttest'>fn main() {
    enum Result&lt;T, E&gt; { Ok(T), Err(E) }
    impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {
        fn unwrap(self) -&gt; T {
            match self {
                Result::Ok(val) =&gt; val,
                Result::Err(err) =&gt;
                  panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err),
            }
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span>: ::<span class='ident'>std</span>::<span class='ident'>fmt</span>::<span class='ident'>Debug</span><span class='op'>&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>unwrap</span>(<span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>T</span> {
        <span class='kw'>match</span> <span class='self'>self</span> {
            <span class='prelude-ty'>Result</span>::<span class='prelude-val'>Ok</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
            <span class='prelude-ty'>Result</span>::<span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span>
              <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;</span>, <span class='ident'>err</span>),
        }
    }
}</pre>

<blockquote>
<p>訳注：</p>

<p>called <code>Result::unwrap()</code> on an <code>Err</code> value: {:?}&quot;：<br/>
<code>Err</code> 値 {:?} に対して <code>Result::unwrap()</code> が呼ばれました</p>
</blockquote>

<!-- This is effectively the same as our [definition for -->

<!-- `Option::unwrap`](#code-option-def-unwrap), except it includes the -->

<!-- error value in the `panic!` message. This makes debugging easier, but -->

<!-- it also requires us to add a [`Debug`][8] constraint on the `E` type -->

<!-- parameter (which represents our error type). Since the vast majority -->

<!-- of types should satisfy the `Debug` constraint, this tends to work out -->

<!-- in practice. (`Debug` on a type simply means that there's a reasonable -->

<!-- way to print a human readable description of values with that type.) -->

<p>これは実質的には私たちの <a href="#code-option-def-unwrap"><code>Option::unwrap</code> の定義</a> と同じですが、 <code>panic!</code> メッセージにエラーの値が含まれているところが異なります。
これはデバッグをより簡単にしますが、一方で、（エラーの型を表す）型パラメータ <code>E</code> に <a href="../std/fmt/trait.Debug.html"><code>Debug</code></a> 制約を付けることが求められます。
大半の型は <code>Debug</code> 制約を満たしているので、実際のところ、うまくいく傾向にあります。
（<code>Debug</code> が型に付くということは、単にその型の値が、人間が読める形式で表示できることを意味しています。）</p>

<!-- OK, let's move on to an example. -->

<p>では、例を見ていきましょう。</p>

<!-- ### Parsing integers -->

<h3 id='整数をパースする' class='section-header'><a href='#整数をパースする'>整数をパースする</a></h3>
<!-- The Rust standard library makes converting strings to integers dead simple. -->

<!-- It's so easy in fact, that it is very tempting to write something like the -->

<!-- following: -->

<p>Rustの標準ライブラリを使うと、文字列を整数に変換することが、すごく簡単にできます。
あまりにも簡単なので、実際のところ、以下のように書きたいという誘惑に負けることがあります：</p>
<span class='rusttest'>fn double_number(number_str: &amp;str) -&gt; i32 {
    2 * number_str.parse::&lt;i32&gt;().unwrap()
}

fn main() {
    let n: i32 = double_number(&quot;10&quot;);
    assert_eq!(n, 20);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>double_number</span>(<span class='ident'>number_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>number_str</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>unwrap</span>()
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>double_number</span>(<span class='string'>&quot;10&quot;</span>);
    <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>n</span>, <span class='number'>20</span>);
}</pre>

<!-- At this point, you should be skeptical of calling `unwrap`. For example, if -->

<!-- the string doesn't parse as a number, you'll get a panic: -->

<p>すでにあなたは、<code>unwrap</code> を呼ぶことについて懐疑的になっているはずです。
例えば、文字列が数字としてパースできなければ、パニックが起こります。</p>

<pre><code class="language-text">thread &#39;&lt;main&gt;&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }&#39;, /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
</code></pre>

<!-- This is rather unsightly, and if this happened inside a library you're -->

<!-- using, you might be understandably annoyed. Instead, we should try to -->

<!-- handle the error in our function and let the caller decide what to -->

<!-- do. This means changing the return type of `double_number`. But to -->

<!-- what? Well, that requires looking at the signature of the [`parse` -->

<!-- method][9] in the standard library: -->

<p>これは少し目障りです。
もしあなたが使っているライブラリの中でこれが起こされたら、イライラするに違いありません。
代わりに、私たちの関数の中でエラーを処理し、呼び出し元にどうするのかを決めさせるべきです。
そのためには、<code>double_number</code> の戻り値の型（リターン型）を変更しなければなりません。
でも、一体何に？
ええと、これはつまり、標準ライブラリの <a href="../std/primitive.str.html#method.parse"><code>parse</code> メソッド</a> のシグネチャを見ろということです。</p>
<span class='rusttest'>fn main() {
    impl str {
        fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>str</span> {
    <span class='kw'>fn</span> <span class='ident'>parse</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>FromStr</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>F</span>, <span class='ident'>F</span>::<span class='prelude-val'>Err</span><span class='op'>&gt;</span>;
}</pre>

<!-- Hmm. So we at least know that we need to use a `Result`. Certainly, it's -->

<!-- possible that this could have returned an `Option`. After all, a string either -->

<!-- parses as a number or it doesn't, right? That's certainly a reasonable way to -->

<!-- go, but the implementation internally distinguishes *why* the string didn't -->

<!-- parse as an integer. (Whether it's an empty string, an invalid digit, too big -->

<!-- or too small.) Therefore, using a `Result` makes sense because we want to -->

<!-- provide more information than simply “absence.” We want to say *why* the -->

<!-- parsing failed. You should try to emulate this line of reasoning when faced -->

<!-- with a choice between `Option` and `Result`. If you can provide detailed error -->

<!-- information, then you probably should. (We'll see more on this later.) -->

<p>うむ。最低でも <code>Result</code> を使わないといけないことはわかりました。
もちろん、これが <code>Option</code> を戻すようにすることも可能だったでしょう。
結局のところ、文字列が数字としてパースできたかどうかが知りたいわけですよね？
それも悪いやり方ではありませんが、実装の内側では <em>なぜ</em> 文字列が整数としてパースできなかったを、ちゃんと区別しています。
（空の文字列だったのか、有効な数字でなかったのか、大きすぎたり、小さすぎたりしたのか。）
従って、<code>Result</code> を使ってより多くの情報を提供するほうが、単に「不在」を示すことよりも理にかなっています。
今後、もし <code>Option</code> と <code>Result</code> のどちらを選ぶという事態に遭遇した時は、このような理由付けのやり方を真似てみてください。
もし詳細なエラー情報を提供できるのなら、多分、それをしたほうがいいでしょう。
（後ほど別の例もお見せます。）</p>

<!-- OK, but how do we write our return type? The `parse` method as defined -->

<!-- above is generic over all the different number types defined in the -->

<!-- standard library. We could (and probably should) also make our -->

<!-- function generic, but let's favor explicitness for the moment. We only -->

<!-- care about `i32`, so we need to [find its implementation of -->

<!-- `FromStr`](../std/primitive.i32.html) (do a `CTRL-F` in your browser -->

<!-- for “FromStr”) and look at its [associated type][10] `Err`. We did -->

<!-- this so we can find the concrete error type. In this case, it's -->

<!-- [`std::num::ParseIntError`](../std/num/struct.ParseIntError.html). -->

<!-- Finally, we can rewrite our function: -->

<p>それでは、リターン型をどう書きましょうか？
上の <code>parse</code> メソッドは一般化されているので、標準ライブラリにある、あらゆる数値型について定義されています。
この関数を同じように一般化することもできますが（そして、そうするべきでしょうが）、今は明快さを優先しましょう。
<code>i32</code> だけを扱うことにしますので、それの <a href="../std/primitive.i32.html"><code>FromStr</code> の実装がどうなっているか探しましょう</a> 。
（ブラウザで <code>CTRL-F</code> を押して「FromStr」を探します。）
そして <a href="../book/associated-types.html">関連型(associated type)</a> から <code>Err</code> を見つけます。
こうすれば、具体的なエラー型が見つかります。
この場合、それは <a href="../std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> です。
これでようやく関数を書き直せます：</p>
<span class='rusttest'>use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match number_str.parse::&lt;i32&gt;() {
        Ok(n) =&gt; Ok(2 * n),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>;

<span class='kw'>fn</span> <span class='ident'>double_number</span>(<span class='ident'>number_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>ParseIntError</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>number_str</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>() {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>),
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>double_number</span>(<span class='string'>&quot;10&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>n</span>, <span class='number'>20</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {:?}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<!-- This is a little better, but now we've written a lot more code! The case -->

<!-- analysis has once again bitten us. -->

<p>これで少し良くなりましたが、たくさんのコードを書いてしまいました！
ケース分析に、またしてもやられたわけです。</p>

<!-- Combinators to the rescue! Just like `Option`, `Result` has lots of combinators -->

<!-- defined as methods. There is a large intersection of common combinators between -->

<!-- `Result` and `Option`. In particular, `map` is part of that intersection: -->

<p>コンビネータに助けを求めましょう！
ちょうど <code>Option</code> と同じように <code>Result</code> にもたくさんのコンビネータが、メソッドとして定義されています。
<code>Result</code> と <code>Option</code> の間では、共通のコンビネータが数多く存在します。
例えば <code>map</code> も共通なものの一つです：</p>
<span class='rusttest'>use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>;

<span class='kw'>fn</span> <span class='ident'>double_number</span>(<span class='ident'>number_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>ParseIntError</span><span class='op'>&gt;</span> {
    <span class='ident'>number_str</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>double_number</span>(<span class='string'>&quot;10&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='ident'>n</span>, <span class='number'>20</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {:?}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<!-- The usual suspects are all there for `Result`, including -->

<!-- [`unwrap_or`](../std/result/enum.Result.html#method.unwrap_or) and -->

<!-- [`and_then`](../std/result/enum.Result.html#method.and_then). -->

<!-- Additionally, since `Result` has a second type parameter, there are -->

<!-- combinators that affect only the error type, such as -->

<!-- [`map_err`](../std/result/enum.Result.html#method.map_err) (instead of -->

<!-- `map`) and [`or_else`](../std/result/enum.Result.html#method.or_else) -->

<!-- (instead of `and_then`). -->

<p><code>Result</code> でいつも候補にあがるのは <a href="../std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> と <a href="../std/result/enum.Result.html#method.and_then"><code>and_then</code></a> です。
さらに <code>Result</code> は2つ目の型パラメータを取りますので、エラー型だけに影響を与える <a href="../std/result/enum.Result.html#method.map_err"><code>map_err</code></a> （<code>map</code> に相当）と <a href="../std/result/enum.Result.html#method.or_else"><code>or_else</code></a> （<code>and_then</code> に相当）もあります。</p>

<!-- ### The `Result` type alias idiom -->

<h3 id='result-型エイリアスを用いたイディオム' class='section-header'><a href='#result-型エイリアスを用いたイディオム'><code>Result</code> 型エイリアスを用いたイディオム</a></h3>
<!-- In the standard library, you may frequently see types like -->

<!-- `Result<i32>`. But wait, [we defined `Result`](#code-result-def) to -->

<!-- have two type parameters. How can we get away with only specifying -->

<!-- one? The key is to define a `Result` type alias that *fixes* one of -->

<!-- the type parameters to a particular type. Usually the fixed type is -->

<!-- the error type. For example, our previous example parsing integers -->

<!-- could be rewritten like this: -->

<p>標準ライブラリでは <code>Result&lt;i32&gt;</code> のような型をよく見ると思います。
でも、待ってください。
2つの型パラメータを取るように <a href="#code-result-def"><code>Result</code> を定義したはずです</a> 。
どうして、1つだけを指定して済んだのでしょう？
種を明かすと、<code>Result</code> の型エイリアスを定義して、一方の型パラメータを特定の型に <em>固定</em> したのです。
通常はエラー型の方を固定します。
例えば、先ほどの整数のパースの例は、こう書き換えることもできます。</p>
<span class='rusttest'>fn main() {
    use std::num::ParseIntError;
    use std::result;
    
    type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;
    
    fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {
        unimplemented!();
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>result</span>;

<span class='kw'>type</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>result</span>::<span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>ParseIntError</span><span class='op'>&gt;</span>;

<span class='kw'>fn</span> <span class='ident'>double_number</span>(<span class='ident'>number_str</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span> {
    <span class='macro'>unimplemented</span><span class='macro'>!</span>();
}</pre>

<!-- Why would we do this? Well, if we have a lot of functions that could return -->

<!-- `ParseIntError`, then it's much more convenient to define an alias that always -->

<!-- uses `ParseIntError` so that we don't have to write it out all the time. -->

<p>なぜ、こうするのでしょうか？
もし <code>ParseIntError</code> を返す関数をたくさん定義するとしたら、常に <code>ParseIntError</code> を使うエイリアスを定義したほうが便利だからです。
こうすれば、同じことを何度も書かずに済みます。</p>

<!-- The most prominent place this idiom is used in the standard library is -->

<!-- with [`io::Result`](../std/io/type.Result.html). Typically, one writes -->

<!-- `io::Result<T>`, which makes it clear that you're using the `io` -->

<!-- module's type alias instead of the plain definition from -->

<!-- `std::result`. (This idiom is also used for -->

<!-- [`fmt::Result`](../std/fmt/type.Result.html).) -->

<p>標準ライブラリで、このイディオムが際立って多く使われている場所では、<a href="../std/io/type.Result.html"><code>io::Result</code></a> を用いています。
それらは通常 <code>io::Result&lt;T&gt;</code> のように書かれ、<code>std::result</code> のプレーンな定義の代わりに <code>io</code> モジュールの型エイリアスを使っていることが、明確にわかるようになっています。</p>

<!-- ## A brief interlude: unwrapping isn't evil -->

<h2 id='小休止アンラップは悪ではない' class='section-header'><a href='#小休止アンラップは悪ではない'>小休止：アンラップは悪ではない</a></h2>
<!-- If you've been following along, you might have noticed that I've taken a pretty -->

<!-- hard line against calling methods like `unwrap` that could `panic` and abort -->

<!-- your program. *Generally speaking*, this is good advice. -->

<p>これまでの説明を読んだあなたは、 <code>unwrap</code> のような <code>panic</code> を起こし、プログラムをアボートするようなメソッドについて、私がきっぱりと否定する方針をとっていたことに気づいたかもしれません。
<em>一般的には</em> これは良いアドバイスです。</p>

<!-- However, `unwrap` can still be used judiciously. What exactly justifies use of -->

<!-- `unwrap` is somewhat of a grey area and reasonable people can disagree. I'll -->

<!-- summarize some of my *opinions* on the matter. -->

<p>しかしながら <code>unwrap</code> を使うのが懸命なこともあります。
どんな場合が <code>unwrap</code> の使用を正当化できるのかについては、グレーな部分があり、人によって意見が分かれます。
ここで、この問題についての、私の <em>個人的な意見</em> をまとめたいと思います。</p>

<!-- * **In examples and quick 'n' dirty code.** Sometimes you're writing examples -->

<!--   or a quick program, and error handling simply isn't important. Beating the -->

<!--   convenience of `unwrap` can be hard in such scenarios, so it is very -->

<!--   appealing. -->

<ul>
<li><strong>即興で書いたサンプルコード。</strong>
サンプルコードや簡単なプログラムを書いていて、エラーハンドリングが単に重要でないこともあります。
このような時に <code>unwrap</code> の便利さは、とても魅力的に映るでしょう。
これに打ち勝つのは難しいことです。</li>
</ul>

<!-- * **When panicking indicates a bug in the program.** When the invariants of -->

<!--   your code should prevent a certain case from happening (like, say, popping -->

<!--   from an empty stack), then panicking can be permissible. This is because it -->

<!--   exposes a bug in your program. This can be explicit, like from an `assert!` -->

<!--   failing, or it could be because your index into an array was out of bounds. -->

<ul>
<li><strong>パニックがプログラムのバグの兆候となる時。</strong>
コードの中の不変条件が、ある特定のケースの発生を未然に防ぐ時（例えば、空のスタックから取り出そうとしたなど）、パニックを起こしても差し支えありません。
なぜなら、そうすることでプログラムに潜むバグが明るみに出るからです。
これは <code>assert!</code> の失敗のような明示的な要因によるものだったり、配列のインデックスが境界から外れたからだったりします。</li>
</ul>

<!-- This is probably not an exhaustive list. Moreover, when using an -->

<!-- `Option`, it is often better to use its -->

<!-- [`expect`](../std/option/enum.Option.html#method.expect) -->

<!-- method. `expect` does exactly the same thing as `unwrap`, except it -->

<!-- prints a message you give to `expect`. This makes the resulting panic -->

<!-- a bit nicer to deal with, since it will show your message instead of -->

<!-- “callaed unwrap on a `None` value.” -->

<p>これは多分、完全なリストではないでしょう。
さらに <code>Option</code> を使う時は、ほとんどの場合で <a href="../std/option/enum.Option.html#method.expect"><code>expect</code></a> メソッドを使う方がいいでしょう。
<code>expect</code> は <code>unwrap</code> とほぼ同じことをしますが、 <code>expect</code> では与えられたメッセージを表示するところが異なります。
この方が結果として起こったパニックを、少し扱いやすいものにします。
なぜなら「 <code>None</code> な値に対してアンラップが呼ばれました」というメッセージの代わりに、指定したメッセージが表示されるからです。</p>

<!-- My advice boils down to this: use good judgment. There's a reason why the words -->

<!-- “never do X” or “Y is considered harmful” don't appear in my writing. There are -->

<!-- trade offs to all things, and it is up to you as the programmer to determine -->

<!-- what is acceptable for your use cases. My goal is only to help you evaluate -->

<!-- trade offs as accurately as possible. -->

<p>私のアドバイスを突き詰めると、よく見極めなさい、ということです。
私の書いた文章の中に「決して、Xをしてはならない」とか「Yは有害だと考えよう」といった言葉が現れないのには、れっきとした理由があります。
あるユースケースでこれが容認できるかどうかは、プログラマであるあなたの判断に委ねられます。
私が目指していることは、あなたがトレードオフをできるかぎり正確に評価できるよう、手助けをすることなのです。</p>

<!-- Now that we've covered the basics of error handling in Rust, and -->

<!-- explained unwrapping, let's start exploring more of the standard -->

<!-- library. -->

<p>これでRustにおけるエラーハンドリングの基礎をカバーできました。
また、アンラップについても解説しました。
では標準ライブラリをもっと探索していきましょう。</p>

<h1 id='working-with-multiple-error-types' class='section-header'><a href='#working-with-multiple-error-types'>Working with multiple error types</a></h1>
<p>Thus far, we&#39;ve looked at error handling where everything was either an
<code>Option&lt;T&gt;</code> or a <code>Result&lt;T, SomeError&gt;</code>. But what happens when you have both an
<code>Option</code> and a <code>Result</code>? Or what if you have a <code>Result&lt;T, Error1&gt;</code> and a
<code>Result&lt;T, Error2&gt;</code>? Handling <em>composition of distinct error types</em> is the next
challenge in front of us, and it will be the major theme throughout the rest of
this chapter.</p>

<h2 id='composing-option-and-result' class='section-header'><a href='#composing-option-and-result'>Composing <code>Option</code> and <code>Result</code></a></h2>
<p>So far, I&#39;ve talked about combinators defined for <code>Option</code> and combinators
defined for <code>Result</code>. We can use these combinators to compose results of
different computations without doing explicit case analysis.</p>

<p>Of course, in real code, things aren&#39;t always as clean. Sometimes you have a
mix of <code>Option</code> and <code>Result</code> types. Must we resort to explicit case analysis,
or can we continue using combinators?</p>

<p>For now, let&#39;s revisit one of the first examples in this chapter:</p>
<span class='rusttest'>use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // error 1
    let n: i32 = arg.parse().unwrap(); // error 2
    println!(&quot;{}&quot;, 2 * n);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>env</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>argv</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>();
    <span class='kw'>let</span> <span class='ident'>arg</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>argv</span>.<span class='ident'>nth</span>(<span class='number'>1</span>).<span class='ident'>unwrap</span>(); <span class='comment'>// error 1</span>
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>arg</span>.<span class='ident'>parse</span>().<span class='ident'>unwrap</span>(); <span class='comment'>// error 2</span>
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>);
}</pre>

<p>Given our new found knowledge of <code>Option</code>, <code>Result</code> and their various
combinators, we should try to rewrite this so that errors are handled properly
and the program doesn&#39;t panic if there&#39;s an error.</p>

<p>The tricky aspect here is that <code>argv.nth(1)</code> produces an <code>Option</code> while
<code>arg.parse()</code> produces a <code>Result</code>. These aren&#39;t directly composable. When faced
with both an <code>Option</code> and a <code>Result</code>, the solution is <em>usually</em> to convert the
<code>Option</code> to a <code>Result</code>. In our case, the absence of a command line parameter
(from <code>env::args()</code>) means the user didn&#39;t invoke the program correctly. We
could just use a <code>String</code> to describe the error. Let&#39;s try:</p>

<p><span id="code-error-double-string"></span></p>
<span class='rusttest'>use std::env;

fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {
    argv.nth(1)
        .ok_or(&quot;Please give at least one argument&quot;.to_owned())
        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))
        .map(|n| 2 * n)
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>env</span>;

<span class='kw'>fn</span> <span class='ident'>double_arg</span>(<span class='kw-2'>mut</span> <span class='ident'>argv</span>: <span class='ident'>env</span>::<span class='ident'>Args</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='ident'>argv</span>.<span class='ident'>nth</span>(<span class='number'>1</span>)
        .<span class='ident'>ok_or</span>(<span class='string'>&quot;Please give at least one argument&quot;</span>.<span class='ident'>to_owned</span>())
        .<span class='ident'>and_then</span>(<span class='op'>|</span><span class='ident'>arg</span><span class='op'>|</span> <span class='ident'>arg</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>err</span><span class='op'>|</span> <span class='ident'>err</span>.<span class='ident'>to_string</span>()))
        .<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>double_arg</span>(<span class='ident'>env</span>::<span class='ident'>args</span>()) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<p>There are a couple new things in this example. The first is the use of the
<a href="../std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a>
combinator. This is one way to convert an <code>Option</code> into a <code>Result</code>. The
conversion requires you to specify what error to use if <code>Option</code> is <code>None</code>.
Like the other combinators we&#39;ve seen, its definition is very simple:</p>
<span class='rusttest'>fn main() {
    fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {
        match option {
            Some(val) =&gt; Ok(val),
            None =&gt; Err(err),
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>ok_or</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span>(<span class='ident'>option</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span>, <span class='ident'>err</span>: <span class='ident'>E</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>T</span>, <span class='ident'>E</span><span class='op'>&gt;</span> {
    <span class='kw'>match</span> <span class='ident'>option</span> {
        <span class='prelude-val'>Some</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Ok</span>(<span class='ident'>val</span>),
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>),
    }
}</pre>

<p>The other new combinator used here is
<a href="../std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>.
This is just like <code>Result::map</code>, except it maps a function on to the <em>error</em>
portion of a <code>Result</code> value. If the <code>Result</code> is an <code>Ok(...)</code> value, then it is
returned unmodified.</p>

<p>We use <code>map_err</code> here because it is necessary for the error types to remain
the same (because of our use of <code>and_then</code>). Since we chose to convert the
<code>Option&lt;String&gt;</code> (from <code>argv.nth(1)</code>) to a <code>Result&lt;String, String&gt;</code>, we must
also convert the <code>ParseIntError</code> from <code>arg.parse()</code> to a <code>String</code>.</p>

<h2 id='the-limits-of-combinators' class='section-header'><a href='#the-limits-of-combinators'>The limits of combinators</a></h2>
<p>Doing IO and parsing input is a very common task, and it&#39;s one that I
personally have done a lot of in Rust. Therefore, we will use (and continue to
use) IO and various parsing routines to exemplify error handling.</p>

<p>Let&#39;s start simple. We are tasked with opening a file, reading all of its
contents and converting its contents to a number. Then we multiply it by <code>2</code>
and print the output.</p>

<p>Although I&#39;ve tried to convince you not to use <code>unwrap</code>, it can be useful
to first write your code using <code>unwrap</code>. It allows you to focus on your problem
instead of the error handling, and it exposes the points where proper error
handling need to occur. Let&#39;s start there so we can get a handle on the code,
and then refactor it to use better error handling.</p>
<span class='rusttest'>use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 {
    let mut file = File::open(file_path).unwrap(); // error 1
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap(); // error 2
    let n: i32 = contents.trim().parse().unwrap(); // error 3
    2 * n
}

fn main() {
    let doubled = file_double(&quot;foobar&quot;);
    println!(&quot;{}&quot;, doubled);
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>unwrap</span>(); <span class='comment'>// error 1</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>unwrap</span>(); <span class='comment'>// error 2</span>
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>().<span class='ident'>unwrap</span>(); <span class='comment'>// error 3</span>
    <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>doubled</span> <span class='op'>=</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>);
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>doubled</span>);
}</pre>

<p>(N.B. The <code>AsRef&lt;Path&gt;</code> is used because those are the
<a href="../std/fs/struct.File.html#method.open">same bounds used on
<code>std::fs::File::open</code></a>.
This makes it ergonomic to use any kind of string as a file path.)</p>

<p>There are three different errors that can occur here:</p>

<ol>
<li>A problem opening the file.</li>
<li>A problem reading data from the file.</li>
<li>A problem parsing the data as a number.</li>
</ol>

<p>The first two problems are described via the
<a href="../std/io/struct.Error.html"><code>std::io::Error</code></a> type. We know this
because of the return types of
<a href="../std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> and
<a href="../std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a>.
(Note that they both use the <a href="#the-result-type-alias-idiom"><code>Result</code> type alias
idiom</a> described previously. If you
click on the <code>Result</code> type, you&#39;ll <a href="../std/io/type.Result.html">see the type
alias</a>, and consequently, the underlying
<code>io::Error</code> type.)  The third problem is described by the
<a href="../std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>
type. The <code>io::Error</code> type in particular is <em>pervasive</em> throughout the
standard library. You will see it again and again.</p>

<p>Let&#39;s start the process of refactoring the <code>file_double</code> function. To make this
function composable with other components of the program, it should <em>not</em> panic
if any of the above error conditions are met. Effectively, this means that the
function should <em>return an error</em> if any of its operations fail. Our problem is
that the return type of <code>file_double</code> is <code>i32</code>, which does not give us any
useful way of reporting an error. Thus, we must start by changing the return
type from <code>i32</code> to something else.</p>

<p>The first thing we need to decide: should we use <code>Option</code> or <code>Result</code>? We
certainly could use <code>Option</code> very easily. If any of the three errors occur, we
could simply return <code>None</code>. This will work <em>and it is better than panicking</em>,
but we can do a lot better. Instead, we should pass some detail about the error
that occurred. Since we want to express the <em>possibility of error</em>, we should
use <code>Result&lt;i32, E&gt;</code>. But what should <code>E</code> be? Since two <em>different</em> types of
errors can occur, we need to convert them to a common type. One such type is
<code>String</code>. Let&#39;s see how that impacts our code:</p>
<span class='rusttest'>use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&amp;mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::&lt;i32&gt;()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>)
         .<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>err</span><span class='op'>|</span> <span class='ident'>err</span>.<span class='ident'>to_string</span>())
         .<span class='ident'>and_then</span>(<span class='op'>|</span><span class='kw-2'>mut</span> <span class='ident'>file</span><span class='op'>|</span> {
              <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
              <span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>)
                  .<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>err</span><span class='op'>|</span> <span class='ident'>err</span>.<span class='ident'>to_string</span>())
                  .<span class='ident'>map</span>(<span class='op'>|</span>_<span class='op'>|</span> <span class='ident'>contents</span>)
         })
         .<span class='ident'>and_then</span>(<span class='op'>|</span><span class='ident'>contents</span><span class='op'>|</span> {
              <span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>()
                      .<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>err</span><span class='op'>|</span> <span class='ident'>err</span>.<span class='ident'>to_string</span>())
         })
         .<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>n</span><span class='op'>|</span> <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<p>This code looks a bit hairy. It can take quite a bit of practice before code
like this becomes easy to write. The way we write it is by <em>following the
types</em>. As soon as we changed the return type of <code>file_double</code> to
<code>Result&lt;i32, String&gt;</code>, we had to start looking for the right combinators. In
this case, we only used three different combinators: <code>and_then</code>, <code>map</code> and
<code>map_err</code>.</p>

<p><code>and_then</code> is used to chain multiple computations where each computation could
return an error. After opening the file, there are two more computations that
could fail: reading from the file and parsing the contents as a number.
Correspondingly, there are two calls to <code>and_then</code>.</p>

<p><code>map</code> is used to apply a function to the <code>Ok(...)</code> value of a <code>Result</code>. For
example, the very last call to <code>map</code> multiplies the <code>Ok(...)</code> value (which is
an <code>i32</code>) by <code>2</code>. If an error had occurred before that point, this operation
would have been skipped because of how <code>map</code> is defined.</p>

<p><code>map_err</code> is the trick that makes all of this work. <code>map_err</code> is just like
<code>map</code>, except it applies a function to the <code>Err(...)</code> value of a <code>Result</code>. In
this case, we want to convert all of our errors to one type: <code>String</code>. Since
both <code>io::Error</code> and <code>num::ParseIntError</code> implement <code>ToString</code>, we can call the
<code>to_string()</code> method to convert them.</p>

<p>With all of that said, the code is still hairy. Mastering use of combinators is
important, but they have their limits. Let&#39;s try a different approach: early
returns.</p>

<h2 id='early-returns' class='section-header'><a href='#early-returns'>Early returns</a></h2>
<p>I&#39;d like to take the code from the previous section and rewrite it using <em>early
returns</em>. Early returns let you exit the function early. We can&#39;t return early
in <code>file_double</code> from inside another closure, so we&#39;ll need to revert back to
explicit case analysis.</p>
<span class='rusttest'>use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = match File::open(file_path) {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&amp;mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) =&gt; n,
        Err(err) =&gt; return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>file</span>) <span class='op'>=&gt;</span> <span class='ident'>file</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>.<span class='ident'>to_string</span>()),
    };
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='kw'>if</span> <span class='kw'>let</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=</span> <span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>) {
        <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>.<span class='ident'>to_string</span>());
    }
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>() {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='ident'>n</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>.<span class='ident'>to_string</span>()),
    };
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<p>Reasonable people can disagree over whether this code is better that the code
that uses combinators, but if you aren&#39;t familiar with the combinator approach,
this code looks simpler to read to me. It uses explicit case analysis with
<code>match</code> and <code>if let</code>. If an error occurs, it simply stops executing the
function and returns the error (by converting it to a string).</p>

<p>Isn&#39;t this a step backwards though? Previously, we said that the key to
ergonomic error handling is reducing explicit case analysis, yet we&#39;ve reverted
back to explicit case analysis here. It turns out, there are <em>multiple</em> ways to
reduce explicit case analysis. Combinators aren&#39;t the only way.</p>

<h2 id='the-try-macro' class='section-header'><a href='#the-try-macro'>The <code>try!</code> macro</a></h2>
<p>A cornerstone of error handling in Rust is the <code>try!</code> macro. The <code>try!</code> macro
abstracts case analysis just like combinators, but unlike combinators, it also
abstracts <em>control flow</em>. Namely, it can abstract the <em>early return</em> pattern
seen above.</p>

<p>Here is a simplified definition of a <code>try!</code> macro:</p>

<p><span id="code-try-def-simple"></span></p>
<span class='rusttest'>fn main() {
    macro_rules! try {
        ($e:expr) =&gt; (match $e {
            Ok(val) =&gt; val,
            Err(err) =&gt; return Err(err),
        });
    }
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>try</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>),
    });
}</pre>

<p>(The <a href="../std/macro.try!.html">real definition</a> is a bit more
sophisticated. We will address that later.)</p>

<p>Using the <code>try!</code> macro makes it very easy to simplify our last example. Since
it does the case analysis and the early return for us, we get tighter code that
is easier to read:</p>
<span class='rusttest'>use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<p>The <code>map_err</code> calls are still necessary given
<a href="#code-try-def-simple">our definition of <code>try!</code></a>.
This is because the error types still need to be converted to <code>String</code>.
The good news is that we will soon learn how to remove those <code>map_err</code> calls!
The bad news is that we will need to learn a bit more about a couple important
traits in the standard library before we can remove the <code>map_err</code> calls.</p>

<h2 id='defining-your-own-error-type' class='section-header'><a href='#defining-your-own-error-type'>Defining your own error type</a></h2>
<p>Before we dive into some of the standard library error traits, I&#39;d like to wrap
up this section by removing the use of <code>String</code> as our error type in the
previous examples.</p>

<p>Using <code>String</code> as we did in our previous examples is convenient because it&#39;s
easy to convert errors to strings, or even make up your own errors as strings
on the spot. However, using <code>String</code> for your errors has some downsides.</p>

<p>The first downside is that the error messages tend to clutter your
code. It&#39;s possible to define the error messages elsewhere, but unless
you&#39;re unusually disciplined, it is very tempting to embed the error
message into your code. Indeed, we did exactly this in a <a href="#code-error-double-string">previous
example</a>.</p>

<p>The second and more important downside is that <code>String</code>s are <em>lossy</em>. That is,
if all errors are converted to strings, then the errors we pass to the caller
become completely opaque. The only reasonable thing the caller can do with a
<code>String</code> error is show it to the user. Certainly, inspecting the string to
determine the type of error is not robust. (Admittedly, this downside is far
more important inside of a library as opposed to, say, an application.)</p>

<p>For example, the <code>io::Error</code> type embeds an
<a href="../std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>,
which is <em>structured data</em> that represents what went wrong during an IO
operation. This is important because you might want to react differently
depending on the error. (e.g., A <code>BrokenPipe</code> error might mean quitting your
program gracefully while a <code>NotFound</code> error might mean exiting with an error
code and showing an error to the user.) With <code>io::ErrorKind</code>, the caller can
examine the type of an error with case analysis, which is strictly superior
to trying to tease out the details of an error inside of a <code>String</code>.</p>

<p>Instead of using a <code>String</code> as an error type in our previous example of reading
an integer from a file, we can define our own error type that represents errors
with <em>structured data</em>. We endeavor to not drop information from underlying
errors in case the caller wants to inspect the details.</p>

<p>The ideal way to represent <em>one of many possibilities</em> is to define our own
sum type using <code>enum</code>. In our case, an error is either an <code>io::Error</code> or a
<code>num::ParseIntError</code>, so a natural definition arises:</p>
<span class='rusttest'>fn main() {
    use std::io;
    use std::num;
    
    // We derive `Debug` because all types should probably derive `Debug`.
    // This gives us a reasonable human readable description of `CliError` values.
    #[derive(Debug)]
    enum CliError {
        Io(io::Error),
        Parse(num::ParseIntError),
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='comment'>// We derive `Debug` because all types should probably derive `Debug`.</span>
<span class='comment'>// This gives us a reasonable human readable description of `CliError` values.</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>Parse</span>(<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>),
}</pre>

<p>Tweaking our code is very easy. Instead of converting errors to strings, we
simply convert them to our <code>CliError</code> type using the corresponding value
constructor:</p>
<span class='rusttest'>#[derive(Debug)]
enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>CliError</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Io</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Io</span>));
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>().<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Parse</span>));
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>match</span> <span class='ident'>file_double</span>(<span class='string'>&quot;foobar&quot;</span>) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>n</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>n</span>),
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Error: {:?}&quot;</span>, <span class='ident'>err</span>),
    }
}</pre>

<p>The only change here is switching <code>map_err(|e| e.to_string())</code> (which converts
errors to strings) to <code>map_err(CliError::Io)</code> or <code>map_err(CliError::Parse)</code>.
The <em>caller</em> gets to decide the level of detail to report to the user. In
effect, using a <code>String</code> as an error type removes choices from the caller while
using a custom <code>enum</code> error type like <code>CliError</code> gives the caller all of the
conveniences as before in addition to <em>structured data</em> describing the error.</p>

<p>A rule of thumb is to define your own error type, but a <code>String</code> error type
will do in a pinch, particularly if you&#39;re writing an application. If you&#39;re
writing a library, defining your own error type should be strongly preferred so
that you don&#39;t remove choices from the caller unnecessarily.</p>

<h1 id='standard-library-traits-used-for-error-handling' class='section-header'><a href='#standard-library-traits-used-for-error-handling'>Standard library traits used for error handling</a></h1>
<p>The standard library defines two integral traits for error handling:
<a href="../std/error/trait.Error.html"><code>std::error::Error</code></a> and
<a href="../std/convert/trait.From.html"><code>std::convert::From</code></a>. While <code>Error</code>
is designed specifically for generically describing errors, the <code>From</code>
trait serves a more general role for converting values between two
distinct types.</p>

<h2 id='the-error-trait' class='section-header'><a href='#the-error-trait'>The <code>Error</code> trait</a></h2>
<p>The <code>Error</code> trait is <a href="../std/error/trait.Error.html">defined in the standard
library</a>:</p>
<span class='rusttest'>fn main() {
    use std::fmt::{Debug, Display};
    
    trait Error: Debug + Display {
      /// A short description of the error.
      fn description(&amp;self) -&gt; &amp;str;
    
      /// The lower level cause of this error, if any.
      fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>::{<span class='ident'>Debug</span>, <span class='ident'>Display</span>};

<span class='kw'>trait</span> <span class='ident'>Error</span>: <span class='ident'>Debug</span> <span class='op'>+</span> <span class='ident'>Display</span> {
  <span class='doccomment'>/// A short description of the error.</span>
  <span class='kw'>fn</span> <span class='ident'>description</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span>;

  <span class='doccomment'>/// The lower level cause of this error, if any.</span>
  <span class='kw'>fn</span> <span class='ident'>cause</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>Error</span><span class='op'>&gt;</span> { <span class='prelude-val'>None</span> }
}</pre>

<p>This trait is super generic because it is meant to be implemented for <em>all</em>
types that represent errors. This will prove useful for writing composable code
as we&#39;ll see later. Otherwise, the trait allows you to do at least the
following things:</p>

<ul>
<li>Obtain a <code>Debug</code> representation of the error.</li>
<li>Obtain a user-facing <code>Display</code> representation of the error.</li>
<li>Obtain a short description of the error (via the <code>description</code> method).</li>
<li>Inspect the causal chain of an error, if one exists (via the <code>cause</code> method).</li>
</ul>

<p>The first two are a result of <code>Error</code> requiring impls for both <code>Debug</code> and
<code>Display</code>. The latter two are from the two methods defined on <code>Error</code>. The
power of <code>Error</code> comes from the fact that all error types impl <code>Error</code>, which
means errors can be existentially quantified as a
<a href="../book/trait-objects.html">trait object</a>.
This manifests as either <code>Box&lt;Error&gt;</code> or <code>&amp;Error</code>. Indeed, the <code>cause</code> method
returns an <code>&amp;Error</code>, which is itself a trait object. We&#39;ll revisit the
<code>Error</code> trait&#39;s utility as a trait object later.</p>

<p>For now, it suffices to show an example implementing the <code>Error</code> trait. Let&#39;s
use the error type we defined in the
<a href="#defining-your-own-error-type">previous section</a>:</p>
<span class='rusttest'>fn main() {
    use std::io;
    use std::num;
    
    // We derive `Debug` because all types should probably derive `Debug`.
    // This gives us a reasonable human readable description of `CliError` values.
    #[derive(Debug)]
    enum CliError {
        Io(io::Error),
        Parse(num::ParseIntError),
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='comment'>// We derive `Debug` because all types should probably derive `Debug`.</span>
<span class='comment'>// This gives us a reasonable human readable description of `CliError` values.</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>Parse</span>(<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>),
}</pre>

<p>This particular error type represents the possibility of two types of errors
occurring: an error dealing with I/O or an error converting a string to a
number. The error could represent as many error types as you want by adding new
variants to the <code>enum</code> definition.</p>

<p>Implementing <code>Error</code> is pretty straight-forward. It&#39;s mostly going to be a lot
explicit case analysis.</p>
<span class='rusttest'>fn main() {
    use std::error;
    use std::fmt;
    
    impl fmt::Display for CliError {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            match *self {
                // Both underlying errors already impl `Display`, so we defer to
                // their implementations.
                CliError::Io(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err),
                CliError::Parse(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),
            }
        }
    }
    
    impl error::Error for CliError {
        fn description(&amp;self) -&gt; &amp;str {
            // Both underlying errors already impl `Error`, so we defer to their
            // implementations.
            match *self {
                CliError::Io(ref err) =&gt; err.description(),
                CliError::Parse(ref err) =&gt; err.description(),
            }
        }
    
        fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
            match *self {
                // N.B. Both of these implicitly cast `err` from their concrete
                // types (either `&amp;io::Error` or `&amp;num::ParseIntError`)
                // to a trait object `&amp;Error`. This works because both error types
                // implement `Error`.
                CliError::Io(ref err) =&gt; Some(err),
                CliError::Parse(ref err) =&gt; Some(err),
            }
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>error</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;

<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Display</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='comment'>// Both underlying errors already impl `Display`, so we defer to</span>
            <span class='comment'>// their implementations.</span>
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;IO error: {}&quot;</span>, <span class='ident'>err</span>),
            <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;Parse error: {}&quot;</span>, <span class='ident'>err</span>),
        }
    }
}

<span class='kw'>impl</span> <span class='ident'>error</span>::<span class='ident'>Error</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>description</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> {
        <span class='comment'>// Both underlying errors already impl `Error`, so we defer to their</span>
        <span class='comment'>// implementations.</span>
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>description</span>(),
            <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>description</span>(),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>cause</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='ident'>error</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='comment'>// N.B. Both of these implicitly cast `err` from their concrete</span>
            <span class='comment'>// types (either `&amp;io::Error` or `&amp;num::ParseIntError`)</span>
            <span class='comment'>// to a trait object `&amp;Error`. This works because both error types</span>
            <span class='comment'>// implement `Error`.</span>
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>err</span>),
            <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Some</span>(<span class='ident'>err</span>),
        }
    }
}</pre>

<p>We note that this is a very typical implementation of <code>Error</code>: match on your
different error types and satisfy the contracts defined for <code>description</code> and
<code>cause</code>.</p>

<h2 id='the-from-trait' class='section-header'><a href='#the-from-trait'>The <code>From</code> trait</a></h2>
<p>The <code>std::convert::From</code> trait is
<a href="../std/convert/trait.From.html">defined in the standard
library</a>:</p>

<p><span id="code-from-def"></span></p>
<span class='rusttest'>fn main() {
    trait From&lt;T&gt; {
        fn from(T) -&gt; Self;
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>trait</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='kw'>Self</span>;
}</pre>

<p>Deliciously simple, yes? <code>From</code> is very useful because it gives us a generic
way to talk about conversion <em>from</em> a particular type <code>T</code> to some other type
(in this case, “some other type” is the subject of the impl, or <code>Self</code>).
The crux of <code>From</code> is the
<a href="../std/convert/trait.From.html">set of implementations provided by the standard
library</a>.</p>

<p>Here are a few simple examples demonstrating how <code>From</code> works:</p>
<span class='rusttest'>fn main() {
    let string: String = From::from(&quot;foo&quot;);
    let bytes: Vec&lt;u8&gt; = From::from(&quot;foo&quot;);
    let cow: ::std::borrow::Cow&lt;str&gt; = From::from(&quot;foo&quot;);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>string</span>: <span class='ident'>String</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='kw'>let</span> <span class='ident'>bytes</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>u8</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);
<span class='kw'>let</span> <span class='ident'>cow</span>: ::<span class='ident'>std</span>::<span class='ident'>borrow</span>::<span class='ident'>Cow</span><span class='op'>&lt;</span><span class='ident'>str</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='string'>&quot;foo&quot;</span>);</pre>

<p>OK, so <code>From</code> is useful for converting between strings. But what about errors?
It turns out, there is one critical impl:</p>
<span class='rusttest'>fn main() {
    impl&lt;&#39;a, E: Error + &#39;a&gt; From&lt;E&gt; for Box&lt;Error + &#39;a&gt;
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='ident'>E</span>: <span class='ident'>Error</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>E</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span></pre>

<p>This impl says that for <em>any</em> type that impls <code>Error</code>, we can convert it to a
trait object <code>Box&lt;Error&gt;</code>. This may not seem terribly surprising, but it is
useful in a generic context.</p>

<p>Remember the two errors we were dealing with previously? Specifically,
<code>io::Error</code> and <code>num::ParseIntError</code>. Since both impl <code>Error</code>, they work with
<code>From</code>:</p>
<span class='rusttest'>fn main() {
    use std::error::Error;
    use std::fs;
    use std::io;
    use std::num;
    
    // We have to jump through some hoops to actually get error values.
    let io_err: io::Error = io::Error::last_os_error();
    let parse_err: num::ParseIntError = &quot;not a number&quot;.parse::&lt;i32&gt;().unwrap_err();
    
    // OK, here are the conversions.
    let err1: Box&lt;Error&gt; = From::from(io_err);
    let err2: Box&lt;Error&gt; = From::from(parse_err);
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>error</span>::<span class='ident'>Error</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='comment'>// We have to jump through some hoops to actually get error values.</span>
<span class='kw'>let</span> <span class='ident'>io_err</span>: <span class='ident'>io</span>::<span class='ident'>Error</span> <span class='op'>=</span> <span class='ident'>io</span>::<span class='ident'>Error</span>::<span class='ident'>last_os_error</span>();
<span class='kw'>let</span> <span class='ident'>parse_err</span>: <span class='ident'>num</span>::<span class='ident'>ParseIntError</span> <span class='op'>=</span> <span class='string'>&quot;not a number&quot;</span>.<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>unwrap_err</span>();

<span class='comment'>// OK, here are the conversions.</span>
<span class='kw'>let</span> <span class='ident'>err1</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='ident'>io_err</span>);
<span class='kw'>let</span> <span class='ident'>err2</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>From</span>::<span class='ident'>from</span>(<span class='ident'>parse_err</span>);</pre>

<p>There is a really important pattern to recognize here. Both <code>err1</code> and <code>err2</code>
have the <em>same type</em>. This is because they are existentially quantified types,
or trait objects. In particular, their underlying type is <em>erased</em> from the
compiler&#39;s knowledge, so it truly sees <code>err1</code> and <code>err2</code> as exactly the same.
Additionally, we constructed <code>err1</code> and <code>err2</code> using precisely the same
function call: <code>From::from</code>. This is because <code>From::from</code> is overloaded on both
its argument and its return type.</p>

<p>This pattern is important because it solves a problem we had earlier: it gives
us a way to reliably convert errors to the same type using the same function.</p>

<p>Time to revisit an old friend; the <code>try!</code> macro.</p>

<h2 id='the-real-try-macro' class='section-header'><a href='#the-real-try-macro'>The real <code>try!</code> macro</a></h2>
<p>Previously, we presented this definition of <code>try!</code>:</p>
<span class='rusttest'>fn main() {
    macro_rules! try {
        ($e:expr) =&gt; (match $e {
            Ok(val) =&gt; val,
            Err(err) =&gt; return Err(err),
        });
    }
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>try</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(<span class='ident'>err</span>),
    });
}</pre>

<p>This is not its real definition. Its real definition is
<a href="../std/macro.try!.html">in the standard library</a>:</p>

<p><span id="code-try-def"></span></p>
<span class='rusttest'>fn main() {
    macro_rules! try {
        ($e:expr) =&gt; (match $e {
            Ok(val) =&gt; val,
            Err(err) =&gt; return Err(::std::convert::From::from(err)),
        });
    }
}</span><pre class='rust rust-example-rendered'>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>try</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span>:<span class='ident'>expr</span>) <span class='op'>=&gt;</span> (<span class='kw'>match</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>e</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>val</span>) <span class='op'>=&gt;</span> <span class='ident'>val</span>,
        <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='kw'>return</span> <span class='prelude-val'>Err</span>(::<span class='ident'>std</span>::<span class='ident'>convert</span>::<span class='ident'>From</span>::<span class='ident'>from</span>(<span class='ident'>err</span>)),
    });
}</pre>

<p>There&#39;s one tiny but powerful change: the error value is passed through
<code>From::from</code>. This makes the <code>try!</code> macro a lot more powerful because it gives
you automatic type conversion for free.</p>

<p>Armed with our more powerful <code>try!</code> macro, let&#39;s take a look at code we wrote
previously to read a file and convert its contents to an integer:</p>
<span class='rusttest'>fn main() {
    use std::fs::File;
    use std::io::Read;
    use std::path::Path;
    
    fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
        let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
        let mut contents = String::new();
        try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
        let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
        Ok(2 * n)
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>String</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>().<span class='ident'>map_err</span>(<span class='op'>|</span><span class='ident'>e</span><span class='op'>|</span> <span class='ident'>e</span>.<span class='ident'>to_string</span>()));
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}</pre>

<p>Earlier, we promised that we could get rid of the <code>map_err</code> calls. Indeed, all
we have to do is pick a type that <code>From</code> works with. As we saw in the previous
section, <code>From</code> has an impl that lets it convert any error type into a
<code>Box&lt;Error&gt;</code>:</p>
<span class='rusttest'>fn main() {
    use std::error::Error;
    use std::fs::File;
    use std::io::Read;
    use std::path::Path;
    
    fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {
        let mut file = try!(File::open(file_path));
        let mut contents = String::new();
        try!(file.read_to_string(&amp;mut contents));
        let n = try!(contents.trim().parse::&lt;i32&gt;());
        Ok(2 * n)
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>error</span>::<span class='ident'>Error</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>&gt;&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>));
    <span class='kw'>let</span> <span class='ident'>n</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>::<span class='op'>&lt;</span><span class='ident'>i32</span><span class='op'>&gt;</span>());
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}</pre>

<p>We are getting very close to ideal error handling. Our code has very little
overhead as a result from error handling because the <code>try!</code> macro encapsulates
three things simultaneously:</p>

<ol>
<li>Case analysis.</li>
<li>Control flow.</li>
<li>Error type conversion.</li>
</ol>

<p>When all three things are combined, we get code that is unencumbered by
combinators, calls to <code>unwrap</code> or case analysis.</p>

<p>There&#39;s one little nit left: the <code>Box&lt;Error&gt;</code> type is <em>opaque</em>. If we
return a <code>Box&lt;Error&gt;</code> to the caller, the caller can&#39;t (easily) inspect
underlying error type. The situation is certainly better than <code>String</code>
because the caller can call methods like
<a href="../std/error/trait.Error.html#tymethod.description"><code>description</code></a>
and <a href="../std/error/trait.Error.html#method.cause"><code>cause</code></a>, but the
limitation remains: <code>Box&lt;Error&gt;</code> is opaque. (N.B. This isn&#39;t entirely
true because Rust does have runtime reflection, which is useful in
some scenarios that are <a href="https://crates.io/crates/error">beyond the scope of this
chapter</a>.)</p>

<p>It&#39;s time to revisit our custom <code>CliError</code> type and tie everything together.</p>

<h2 id='composing-custom-error-types' class='section-header'><a href='#composing-custom-error-types'>Composing custom error types</a></h2>
<p>In the last section, we looked at the real <code>try!</code> macro and how it does
automatic type conversion for us by calling <code>From::from</code> on the error value.
In particular, we converted errors to <code>Box&lt;Error&gt;</code>, which works, but the type
is opaque to callers.</p>

<p>To fix this, we use the same remedy that we&#39;re already familiar with: a custom
error type. Once again, here is the code that reads the contents of a file and
converts it to an integer:</p>
<span class='rusttest'>fn main() {
    use std::fs::File;
    use std::io::{self, Read};
    use std::num;
    use std::path::Path;
    
    // We derive `Debug` because all types should probably derive `Debug`.
    // This gives us a reasonable human readable description of `CliError` values.
    #[derive(Debug)]
    enum CliError {
        Io(io::Error),
        Parse(num::ParseIntError),
    }
    
    fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
        let mut file = try!(File::open(file_path).map_err(CliError::Io));
        let mut contents = String::new();
        try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
        let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
        Ok(2 * n)
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='self'>self</span>, <span class='ident'>Read</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='comment'>// We derive `Debug` because all types should probably derive `Debug`.</span>
<span class='comment'>// This gives us a reasonable human readable description of `CliError` values.</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>Parse</span>(<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>),
}

<span class='kw'>fn</span> <span class='ident'>file_double_verbose</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>CliError</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Io</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>).<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Io</span>));
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>().<span class='ident'>map_err</span>(<span class='ident'>CliError</span>::<span class='ident'>Parse</span>));
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}</pre>

<p>Notice that we still have the calls to <code>map_err</code>. Why? Well, recall the
definitions of <a href="#code-try-def"><code>try!</code></a> and <a href="#code-from-def"><code>From</code></a>. The
problem is that there is no <code>From</code> impl that allows us to convert from error
types like <code>io::Error</code> and <code>num::ParseIntError</code> to our own custom <code>CliError</code>.
Of course, it is easy to fix this! Since we defined <code>CliError</code>, we can impl
<code>From</code> with it:</p>
<span class='rusttest'>fn main() {
    #[derive(Debug)]
    enum CliError { Io(io::Error), Parse(num::ParseIntError) }
    use std::io;
    use std::num;
    
    impl From&lt;io::Error&gt; for CliError {
        fn from(err: io::Error) -&gt; CliError {
            CliError::Io(err)
        }
    }
    
    impl From&lt;num::ParseIntError&gt; for CliError {
        fn from(err: num::ParseIntError) -&gt; CliError {
            CliError::Parse(err)
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>io</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>io</span>::<span class='ident'>Error</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='ident'>err</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>num</span>::<span class='ident'>ParseIntError</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>num</span>::<span class='ident'>ParseIntError</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>Parse</span>(<span class='ident'>err</span>)
    }
}</pre>

<p>All these impls are doing is teaching <code>From</code> how to create a <code>CliError</code> from
other error types. In our case, construction is as simple as invoking the
corresponding value constructor. Indeed, it is <em>typically</em> this easy.</p>

<p>We can finally rewrite <code>file_double</code>:</p>
<span class='rusttest'>fn main() {
    use std::io;
    use std::num;
    enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
    impl From&lt;io::Error&gt; for CliError {
        fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }
    }
    impl From&lt;num::ParseIntError&gt; for CliError {
        fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }
    }
    
    use std::fs::File;
    use std::io::Read;
    use std::path::Path;
    
    fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
        let mut file = try!(File::open(file_path));
        let mut contents = String::new();
        try!(file.read_to_string(&amp;mut contents));
        let n: i32 = try!(contents.trim().parse());
        Ok(2 * n)
    }
}</span><pre class='rust rust-example-rendered'>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fs</span>::<span class='ident'>File</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Read</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>path</span>::<span class='ident'>Path</span>;

<span class='kw'>fn</span> <span class='ident'>file_double</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>CliError</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>contents</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
    <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>file</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>contents</span>));
    <span class='kw'>let</span> <span class='ident'>n</span>: <span class='ident'>i32</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>contents</span>.<span class='ident'>trim</span>().<span class='ident'>parse</span>());
    <span class='prelude-val'>Ok</span>(<span class='number'>2</span> <span class='op'>*</span> <span class='ident'>n</span>)
}</pre>

<p>The only thing we did here was remove the calls to <code>map_err</code>. They are no
longer needed because the <code>try!</code> macro invokes <code>From::from</code> on the error value.
This works because we&#39;ve provided <code>From</code> impls for all the error types that
could appear.</p>

<p>If we modified our <code>file_double</code> function to perform some other operation, say,
convert a string to a float, then we&#39;d need to add a new variant to our error
type:</p>
<span class='rusttest'>fn main() {
    use std::io;
    use std::num;
    
    enum CliError {
        Io(io::Error),
        ParseInt(num::ParseIntError),
        ParseFloat(num::ParseFloatError),
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>ParseInt</span>(<span class='ident'>num</span>::<span class='ident'>ParseIntError</span>),
    <span class='ident'>ParseFloat</span>(<span class='ident'>num</span>::<span class='ident'>ParseFloatError</span>),
}</pre>

<p>And add a new <code>From</code> impl:</p>
<span class='rusttest'>fn main() {
    enum CliError {
        Io(::std::io::Error),
        ParseInt(num::ParseIntError),
        ParseFloat(num::ParseFloatError),
    }
    
    use std::num;
    
    impl From&lt;num::ParseFloatError&gt; for CliError {
        fn from(err: num::ParseFloatError) -&gt; CliError {
            CliError::ParseFloat(err)
        }
    }
}</span><pre class='rust rust-example-rendered'>

<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>num</span>;

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>num</span>::<span class='ident'>ParseFloatError</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>num</span>::<span class='ident'>ParseFloatError</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>ParseFloat</span>(<span class='ident'>err</span>)
    }
}</pre>

<p>And that&#39;s it!</p>

<h2 id='advice-for-library-writers' class='section-header'><a href='#advice-for-library-writers'>Advice for library writers</a></h2>
<p>If your library needs to report custom errors, then you should
probably define your own error type. It&#39;s up to you whether or not to
expose its representation (like
<a href="../std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>) or keep it hidden (like
<a href="../std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>). Regardless
of how you do it, it&#39;s usually good practice to at least provide some
information about the error beyond just its <code>String</code>
representation. But certainly, this will vary depending on use cases.</p>

<p>At a minimum, you should probably implement the
<a href="../std/error/trait.Error.html"><code>Error</code></a>
trait. This will give users of your library some minimum flexibility for
<a href="#the-real-try-macro">composing errors</a>. Implementing the <code>Error</code> trait also
means that users are guaranteed the ability to obtain a string representation
of an error (because it requires impls for both <code>fmt::Debug</code> and
<code>fmt::Display</code>).</p>

<p>Beyond that, it can also be useful to provide implementations of <code>From</code> on your
error types. This allows you (the library author) and your users to
<a href="#composing-custom-error-types">compose more detailed errors</a>. For example,
<a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a>
provides <code>From</code> impls for both <code>io::Error</code> and <code>byteorder::Error</code>.</p>

<p>Finally, depending on your tastes, you may also want to define a
<a href="#the-result-type-alias-idiom"><code>Result</code> type alias</a>, particularly if your
library defines a single error type. This is used in the standard library
for <a href="../std/io/type.Result.html"><code>io::Result</code></a>
and <a href="../std/fmt/type.Result.html"><code>fmt::Result</code></a>.</p>

<h1 id='case-study-a-program-to-read-population-data' class='section-header'><a href='#case-study-a-program-to-read-population-data'>Case study: A program to read population data</a></h1>
<p>This chapter was long, and depending on your background, it might be
rather dense. While there is plenty of example code to go along with
the prose, most of it was specifically designed to be pedagogical. So,
we&#39;re going to do something new: a case study.</p>

<p>For this, we&#39;re going to build up a command line program that lets you
query world population data. The objective is simple: you give it a location
and it will tell you the population. Despite the simplicity, there is a lot
that can go wrong!</p>

<p>The data we&#39;ll be using comes from the <a href="https://github.com/petewarden/dstkdata">Data Science
Toolkit</a>. I&#39;ve prepared some data from it for this exercise. You
can either grab the <a href="http://burntsushi.net/stuff/worldcitiespop.csv.gz">world population data</a> (41MB gzip compressed,
145MB uncompressed) or just the <a href="http://burntsushi.net/stuff/uscitiespop.csv.gz">US population data</a> (2.2MB gzip
compressed, 7.2MB uncompressed).</p>

<p>Up until now, we&#39;ve kept the code limited to Rust&#39;s standard library. For a real
task like this though, we&#39;ll want to at least use something to parse CSV data,
parse the program arguments and decode that stuff into Rust types automatically. For that, we&#39;ll use the
<a href="https://crates.io/crates/csv"><code>csv</code></a>,
and <a href="https://crates.io/crates/rustc-serialize"><code>rustc-serialize</code></a> crates.</p>

<h2 id='initial-setup' class='section-header'><a href='#initial-setup'>Initial setup</a></h2>
<p>We&#39;re not going to spend a lot of time on setting up a project with
Cargo because it is already covered well in <a href="../book/hello-cargo.html">the Cargo
chapter</a> and <a href="http://doc.crates.io/guide.html">Cargo&#39;s documentation</a>.</p>

<p>To get started from scratch, run <code>cargo new --bin city-pop</code> and make sure your
<code>Cargo.toml</code> looks something like this:</p>

<pre><code class="language-text">[package]
name = &quot;city-pop&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;]

[[bin]]
name = &quot;city-pop&quot;

[dependencies]
csv = &quot;0.*&quot;
rustc-serialize = &quot;0.*&quot;
getopts = &quot;0.*&quot;
</code></pre>

<p>You should already be able to run:</p>

<pre><code class="language-text">cargo build --release
./target/release/city-pop
# Outputs: Hello, world!
</code></pre>

<h2 id='argument-parsing' class='section-header'><a href='#argument-parsing'>Argument parsing</a></h2>
<p>Let&#39;s get argument parsing out of the way. We won&#39;t go into too much
detail on Getopts, but there is <a href="http://doc.rust-lang.org/getopts/getopts/index.html">some good documentation</a>
describing it. The short story is that Getopts generates an argument
parser and a help message from a vector of options (The fact that it
is a vector is hidden behind a struct and a set of methods). Once the
parsing is done, we can decode the program arguments into a Rust
struct. From there, we can get information about the flags, for
instance, whether they were passed in, and what arguments they
had. Here&#39;s our program with the appropriate <code>extern crate</code>
statements, and the basic argument setup for Getopts:</p>
<span class='rusttest'>extern crate getopts;
extern crate rustc_serialize;

use getopts::Options;
use std::env;

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
    Err(e) =&gt; { panic!(e.to_string()) }
    };
    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
    return;
    }
    let data_path = args[1].clone();
    let city = args[2].clone();

    // Do stuff with information
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>getopts</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rustc_serialize</span>;

<span class='kw'>use</span> <span class='ident'>getopts</span>::<span class='ident'>Options</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>env</span>;

<span class='kw'>fn</span> <span class='ident'>print_usage</span>(<span class='ident'>program</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>opts</span>: <span class='ident'>Options</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>opts</span>.<span class='ident'>usage</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, <span class='ident'>program</span>)));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>args</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>().<span class='ident'>collect</span>();
    <span class='kw'>let</span> <span class='ident'>program</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>0</span>].<span class='ident'>clone</span>();

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
    <span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>opts</span>.<span class='ident'>parse</span>(<span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>..]) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>m</span>)  <span class='op'>=&gt;</span> { <span class='ident'>m</span> }
    <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='ident'>e</span>.<span class='ident'>to_string</span>()) }
    };
    <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>opt_present</span>(<span class='string'>&quot;h&quot;</span>) {
        <span class='ident'>print_usage</span>(<span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='ident'>opts</span>);
    <span class='kw'>return</span>;
    }
    <span class='kw'>let</span> <span class='ident'>data_path</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>1</span>].<span class='ident'>clone</span>();
    <span class='kw'>let</span> <span class='ident'>city</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>2</span>].<span class='ident'>clone</span>();

    <span class='comment'>// Do stuff with information</span>
}</pre>

<p>First, we get a vector of the arguments passed into our program. We
then store the first one, knowing that it is our program&#39;s name. Once
that&#39;s done, we set up our argument flags, in this case a simplistic
help message flag. Once we have the argument flags set up, we use
<code>Options.parse</code> to parse the argument vector (starting from index one,
because index 0 is the program name). If this was successful, we
assign matches to the parsed object, if not, we panic. Once past that,
we test if the user passed in the help flag, and if so print the usage
message. The option help messages are constructed by Getopts, so all
we have to do to print the usage message is tell it what we want it to
print for the program name and template. If the user has not passed in
the help flag, we assign the proper variables to their corresponding
arguments.</p>

<h2 id='writing-the-logic' class='section-header'><a href='#writing-the-logic'>Writing the logic</a></h2>
<p>We all write code differently, but error handling is usually the last thing we
want to think about. This isn&#39;t great for the overall design of a program, but
it can be useful for rapid prototyping. Because Rust forces us to be explicit
about error handling (by making us call <code>unwrap</code>), it is easy to see which
parts of our program can cause errors.</p>

<p>In this case study, the logic is really simple. All we need to do is parse the
CSV data given to us and print out a field in matching rows. Let&#39;s do it. (Make
sure to add <code>extern crate csv;</code> to the top of your file.)</p>
<span class='rusttest'>// This struct represents the data in each row of the CSV file.
// Type based decoding absolves us of a lot of the nitty gritty error
// handling, like parsing strings as integers or floats.
#[derive(Debug, RustcDecodable)]
struct Row {
    country: String,
    city: String,
    accent_city: String,
    region: String,

    // Not every row has data for the population, latitude or longitude!
    // So we express them as `Option` types, which admits the possibility of
    // absence. The CSV parser will fill in the correct value for us.
    population: Option&lt;u64&gt;,
    latitude: Option&lt;f64&gt;,
    longitude: Option&lt;f64&gt;,
}

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };

    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
        return;
    }

    let data_file = args[1].clone();
    let data_path = Path::new(&amp;data_file);
    let city = args[2].clone();

    let file = fs::File::open(data_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);

    for row in rdr.decode::&lt;Row&gt;() {
        let row = row.unwrap();

        if row.city == city {
            println!(&quot;{}, {}: {:?}&quot;,
                row.city, row.country,
                row.population.expect(&quot;population count&quot;));
        }
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='comment'>// This struct represents the data in each row of the CSV file.</span>
<span class='comment'>// Type based decoding absolves us of a lot of the nitty gritty error</span>
<span class='comment'>// handling, like parsing strings as integers or floats.</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>, <span class='ident'>RustcDecodable</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Row</span> {
    <span class='ident'>country</span>: <span class='ident'>String</span>,
    <span class='ident'>city</span>: <span class='ident'>String</span>,
    <span class='ident'>accent_city</span>: <span class='ident'>String</span>,
    <span class='ident'>region</span>: <span class='ident'>String</span>,

    <span class='comment'>// Not every row has data for the population, latitude or longitude!</span>
    <span class='comment'>// So we express them as `Option` types, which admits the possibility of</span>
    <span class='comment'>// absence. The CSV parser will fill in the correct value for us.</span>
    <span class='ident'>population</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>u64</span><span class='op'>&gt;</span>,
    <span class='ident'>latitude</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span>,
    <span class='ident'>longitude</span>: <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>f64</span><span class='op'>&gt;</span>,
}

<span class='kw'>fn</span> <span class='ident'>print_usage</span>(<span class='ident'>program</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>opts</span>: <span class='ident'>Options</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>opts</span>.<span class='ident'>usage</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, <span class='ident'>program</span>)));
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>args</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>().<span class='ident'>collect</span>();
    <span class='kw'>let</span> <span class='ident'>program</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>0</span>].<span class='ident'>clone</span>();

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
    <span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>opts</span>.<span class='ident'>parse</span>(<span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>..]) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>m</span>)  <span class='op'>=&gt;</span> { <span class='ident'>m</span> }
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='ident'>e</span>.<span class='ident'>to_string</span>()) }
    };

    <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>opt_present</span>(<span class='string'>&quot;h&quot;</span>) {
        <span class='ident'>print_usage</span>(<span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='ident'>opts</span>);
        <span class='kw'>return</span>;
    }

    <span class='kw'>let</span> <span class='ident'>data_file</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>1</span>].<span class='ident'>clone</span>();
    <span class='kw'>let</span> <span class='ident'>data_path</span> <span class='op'>=</span> <span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>data_file</span>);
    <span class='kw'>let</span> <span class='ident'>city</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>2</span>].<span class='ident'>clone</span>();

    <span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>data_path</span>).<span class='ident'>unwrap</span>();
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>file</span>);

    <span class='kw'>for</span> <span class='ident'>row</span> <span class='kw'>in</span> <span class='ident'>rdr</span>.<span class='ident'>decode</span>::<span class='op'>&lt;</span><span class='ident'>Row</span><span class='op'>&gt;</span>() {
        <span class='kw'>let</span> <span class='ident'>row</span> <span class='op'>=</span> <span class='ident'>row</span>.<span class='ident'>unwrap</span>();

        <span class='kw'>if</span> <span class='ident'>row</span>.<span class='ident'>city</span> <span class='op'>==</span> <span class='ident'>city</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>,
                <span class='ident'>row</span>.<span class='ident'>city</span>, <span class='ident'>row</span>.<span class='ident'>country</span>,
                <span class='ident'>row</span>.<span class='ident'>population</span>.<span class='ident'>expect</span>(<span class='string'>&quot;population count&quot;</span>));
        }
    }
}</pre>

<p>Let&#39;s outline the errors. We can start with the obvious: the three places that
<code>unwrap</code> is called:</p>

<ol>
<li><a href="../std/fs/struct.File.html#method.open"><code>fs::File::open</code></a>
can return an
<a href="../std/io/struct.Error.html"><code>io::Error</code></a>.</li>
<li><a href="http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode"><code>csv::Reader::decode</code></a>
decodes one record at a time, and
<a href="http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">decoding a
record</a>
(look at the <code>Item</code> associated type on the <code>Iterator</code> impl)
can produce a
<a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a>.</li>
<li>If <code>row.population</code> is <code>None</code>, then calling <code>expect</code> will panic.</li>
</ol>

<p>Are there any others? What if we can&#39;t find a matching city? Tools like <code>grep</code>
will return an error code, so we probably should too. So we have logic errors
specific to our problem, IO errors and CSV parsing errors. We&#39;re going to
explore two different ways to approach handling these errors.</p>

<p>I&#39;d like to start with <code>Box&lt;Error&gt;</code>. Later, we&#39;ll see how defining our own
error type can be useful.</p>

<h2 id='error-handling-with-boxerror' class='section-header'><a href='#error-handling-with-boxerror'>Error handling with <code>Box&lt;Error&gt;</code></a></h2>
<p><code>Box&lt;Error&gt;</code> is nice because it <em>just works</em>. You don&#39;t need to define your own
error types and you don&#39;t need any <code>From</code> implementations. The downside is that
since <code>Box&lt;Error&gt;</code> is a trait object, it <em>erases the type</em>, which means the
compiler can no longer reason about its underlying type.</p>

<p><a href="#the-limits-of-combinators">Previously</a> we started refactoring our code by
changing the type of our function from <code>T</code> to <code>Result&lt;T, OurErrorType&gt;</code>. In
this case, <code>OurErrorType</code> is just <code>Box&lt;Error&gt;</code>. But what&#39;s <code>T</code>? And can we add
a return type to <code>main</code>?</p>

<p>The answer to the second question is no, we can&#39;t. That means we&#39;ll need to
write a new function. But what is <code>T</code>? The simplest thing we can do is to
return a list of matching <code>Row</code> values as a <code>Vec&lt;Row&gt;</code>. (Better code would
return an iterator, but that is left as an exercise to the reader.)</p>

<p>Let&#39;s refactor our code into its own function, but keep the calls to <code>unwrap</code>.
Note that we opt to handle the possibility of a missing population count by
simply ignoring that row.</p>
<span class='rusttest'>struct Row {
    // unchanged
}

struct PopulationCount {
    city: String,
    country: String,
    // This is no longer an `Option` because values of this type are only
    // constructed if they have a population count.
    count: u64,
}

fn print_usage(program: &amp;str, opts: Options) {
    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));
}

fn search&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: &amp;str) -&gt; Vec&lt;PopulationCount&gt; {
    let mut found = vec![];
    let file = fs::File::open(file_path).unwrap();
    let mut rdr = csv::Reader::from_reader(file);
    for row in rdr.decode::&lt;Row&gt;() {
        let row = row.unwrap();
        match row.population {
            None =&gt; { } // skip it
            Some(count) =&gt; if row.city == city {
                found.push(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    found
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    let program = args[0].clone();

    let mut opts = Options::new();
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);

    let matches = match opts.parse(&amp;args[1..]) {
        Ok(m)  =&gt; { m }
        Err(e) =&gt; { panic!(e.to_string()) }
    };
    if matches.opt_present(&quot;h&quot;) {
        print_usage(&amp;program, opts);
        return;
    }

    let data_file = args[1].clone();
    let data_path = Path::new(&amp;data_file);
    let city = args[2].clone();
    for pop in search(&amp;data_path, &amp;city) {
        println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
    }
}
</span><pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Row</span> {
    <span class='comment'>// unchanged</span>
}

<span class='kw'>struct</span> <span class='ident'>PopulationCount</span> {
    <span class='ident'>city</span>: <span class='ident'>String</span>,
    <span class='ident'>country</span>: <span class='ident'>String</span>,
    <span class='comment'>// This is no longer an `Option` because values of this type are only</span>
    <span class='comment'>// constructed if they have a population count.</span>
    <span class='ident'>count</span>: <span class='ident'>u64</span>,
}

<span class='kw'>fn</span> <span class='ident'>print_usage</span>(<span class='ident'>program</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>opts</span>: <span class='ident'>Options</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>opts</span>.<span class='ident'>usage</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;</span>, <span class='ident'>program</span>)));
}

<span class='kw'>fn</span> <span class='ident'>search</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>(<span class='ident'>file_path</span>: <span class='ident'>P</span>, <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PopulationCount</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>found</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    <span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>).<span class='ident'>unwrap</span>();
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>file</span>);
    <span class='kw'>for</span> <span class='ident'>row</span> <span class='kw'>in</span> <span class='ident'>rdr</span>.<span class='ident'>decode</span>::<span class='op'>&lt;</span><span class='ident'>Row</span><span class='op'>&gt;</span>() {
        <span class='kw'>let</span> <span class='ident'>row</span> <span class='op'>=</span> <span class='ident'>row</span>.<span class='ident'>unwrap</span>();
        <span class='kw'>match</span> <span class='ident'>row</span>.<span class='ident'>population</span> {
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { } <span class='comment'>// skip it</span>
            <span class='prelude-val'>Some</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='ident'>row</span>.<span class='ident'>city</span> <span class='op'>==</span> <span class='ident'>city</span> {
                <span class='ident'>found</span>.<span class='ident'>push</span>(<span class='ident'>PopulationCount</span> {
                    <span class='ident'>city</span>: <span class='ident'>row</span>.<span class='ident'>city</span>,
                    <span class='ident'>country</span>: <span class='ident'>row</span>.<span class='ident'>country</span>,
                    <span class='ident'>count</span>: <span class='ident'>count</span>,
                });
            },
        }
    }
    <span class='ident'>found</span>
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>args</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>env</span>::<span class='ident'>args</span>().<span class='ident'>collect</span>();
    <span class='kw'>let</span> <span class='ident'>program</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>0</span>].<span class='ident'>clone</span>();

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
    <span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);

    <span class='kw'>let</span> <span class='ident'>matches</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>opts</span>.<span class='ident'>parse</span>(<span class='kw-2'>&amp;</span><span class='ident'>args</span>[<span class='number'>1</span>..]) {
        <span class='prelude-val'>Ok</span>(<span class='ident'>m</span>)  <span class='op'>=&gt;</span> { <span class='ident'>m</span> }
        <span class='prelude-val'>Err</span>(<span class='ident'>e</span>) <span class='op'>=&gt;</span> { <span class='macro'>panic</span><span class='macro'>!</span>(<span class='ident'>e</span>.<span class='ident'>to_string</span>()) }
    };
    <span class='kw'>if</span> <span class='ident'>matches</span>.<span class='ident'>opt_present</span>(<span class='string'>&quot;h&quot;</span>) {
        <span class='ident'>print_usage</span>(<span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='ident'>opts</span>);
        <span class='kw'>return</span>;
    }

    <span class='kw'>let</span> <span class='ident'>data_file</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>1</span>].<span class='ident'>clone</span>();
    <span class='kw'>let</span> <span class='ident'>data_path</span> <span class='op'>=</span> <span class='ident'>Path</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>data_file</span>);
    <span class='kw'>let</span> <span class='ident'>city</span> <span class='op'>=</span> <span class='ident'>args</span>[<span class='number'>2</span>].<span class='ident'>clone</span>();
    <span class='kw'>for</span> <span class='ident'>pop</span> <span class='kw'>in</span> <span class='ident'>search</span>(<span class='kw-2'>&amp;</span><span class='ident'>data_path</span>, <span class='kw-2'>&amp;</span><span class='ident'>city</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>, <span class='ident'>pop</span>.<span class='ident'>city</span>, <span class='ident'>pop</span>.<span class='ident'>country</span>, <span class='ident'>pop</span>.<span class='ident'>count</span>);
    }
}
</pre>

<p>While we got rid of one use of <code>expect</code> (which is a nicer variant of <code>unwrap</code>),
we still should handle the absence of any search results.</p>

<p>To convert this to proper error handling, we need to do the following:</p>

<ol>
<li>Change the return type of <code>search</code> to be <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>.</li>
<li>Use the <a href="#code-try-def"><code>try!</code> macro</a> so that errors are returned to the
caller instead of panicking the program.</li>
<li>Handle the error in <code>main</code>.</li>
</ol>

<p>Let&#39;s try it:</p>
<span class='rusttest'>fn main() {
    fn search&lt;P: AsRef&lt;Path&gt;&gt;
             (file_path: P, city: &amp;str)
             -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; {
        let mut found = vec![];
        let file = try!(fs::File::open(file_path));
        let mut rdr = csv::Reader::from_reader(file);
        for row in rdr.decode::&lt;Row&gt;() {
            let row = try!(row);
            match row.population {
                None =&gt; { } // skip it
                Some(count) =&gt; if row.city == city {
                    found.push(PopulationCount {
                        city: row.city,
                        country: row.country,
                        count: count,
                    });
                },
            }
        }
        if found.is_empty() {
            Err(From::from(&quot;No matching cities with a population were found.&quot;))
        } else {
            Ok(found)
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>search</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>
         (<span class='ident'>file_path</span>: <span class='ident'>P</span>, <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>)
         <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PopulationCount</span><span class='op'>&gt;</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>+</span><span class='ident'>Send</span><span class='op'>+</span><span class='ident'>Sync</span><span class='op'>&gt;&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>found</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    <span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>));
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>file</span>);
    <span class='kw'>for</span> <span class='ident'>row</span> <span class='kw'>in</span> <span class='ident'>rdr</span>.<span class='ident'>decode</span>::<span class='op'>&lt;</span><span class='ident'>Row</span><span class='op'>&gt;</span>() {
        <span class='kw'>let</span> <span class='ident'>row</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>row</span>);
        <span class='kw'>match</span> <span class='ident'>row</span>.<span class='ident'>population</span> {
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { } <span class='comment'>// skip it</span>
            <span class='prelude-val'>Some</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='ident'>row</span>.<span class='ident'>city</span> <span class='op'>==</span> <span class='ident'>city</span> {
                <span class='ident'>found</span>.<span class='ident'>push</span>(<span class='ident'>PopulationCount</span> {
                    <span class='ident'>city</span>: <span class='ident'>row</span>.<span class='ident'>city</span>,
                    <span class='ident'>country</span>: <span class='ident'>row</span>.<span class='ident'>country</span>,
                    <span class='ident'>count</span>: <span class='ident'>count</span>,
                });
            },
        }
    }
    <span class='kw'>if</span> <span class='ident'>found</span>.<span class='ident'>is_empty</span>() {
        <span class='prelude-val'>Err</span>(<span class='ident'>From</span>::<span class='ident'>from</span>(<span class='string'>&quot;No matching cities with a population were found.&quot;</span>))
    } <span class='kw'>else</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>found</span>)
    }
}</pre>

<p>Instead of <code>x.unwrap()</code>, we now have <code>try!(x)</code>. Since our function returns a
<code>Result&lt;T, E&gt;</code>, the <code>try!</code> macro will return early from the function if an
error occurs.</p>

<p>There is one big gotcha in this code: we used <code>Box&lt;Error + Send + Sync&gt;</code>
instead of <code>Box&lt;Error&gt;</code>. We did this so we could convert a plain string to an
error type. We need these extra bounds so that we can use the
<a href="../std/convert/trait.From.html">corresponding <code>From</code>
impls</a>:</p>
<span class='rusttest'>fn main() {
    // We are making use of this impl in the code above, since we call `From::from`
    // on a `&amp;&#39;static str`.
    impl&lt;&#39;a, &#39;b&gt; From&lt;&amp;&#39;b str&gt; for Box&lt;Error + Send + Sync + &#39;a&gt;
    
    // But this is also useful when you need to allocate a new string for an
    // error message, usually with `format!`.
    impl From&lt;String&gt; for Box&lt;Error + Send + Sync&gt;
}</span><pre class='rust rust-example-rendered'>
<span class='comment'>// We are making use of this impl in the code above, since we call `From::from`</span>
<span class='comment'>// on a `&amp;&#39;static str`.</span>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='lifetime'>&#39;a</span>, <span class='lifetime'>&#39;b</span><span class='op'>&gt;</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='kw-2'>&amp;</span><span class='lifetime'>&#39;b</span> <span class='ident'>str</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span> <span class='op'>+</span> <span class='ident'>Send</span> <span class='op'>+</span> <span class='ident'>Sync</span> <span class='op'>+</span> <span class='lifetime'>&#39;a</span><span class='op'>&gt;</span>

<span class='comment'>// But this is also useful when you need to allocate a new string for an</span>
<span class='comment'>// error message, usually with `format!`.</span>
<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span> <span class='op'>+</span> <span class='ident'>Send</span> <span class='op'>+</span> <span class='ident'>Sync</span><span class='op'>&gt;</span></pre>

<p>Since <code>search</code> now returns a <code>Result&lt;T, E&gt;</code>, <code>main</code> should use case analysis
when calling <code>search</code>:</p>
<span class='rusttest'>fn main() {
    ...
    match search(&amp;data_file, &amp;city) {
        Ok(pops) =&gt; {
            for pop in pops {
                println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
            }
        }
        Err(err) =&gt; println!(&quot;{}&quot;, err)
    }
    ...
}</span><pre class='rust rust-example-rendered'>
...
<span class='kw'>match</span> <span class='ident'>search</span>(<span class='kw-2'>&amp;</span><span class='ident'>data_file</span>, <span class='kw-2'>&amp;</span><span class='ident'>city</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>pops</span>) <span class='op'>=&gt;</span> {
        <span class='kw'>for</span> <span class='ident'>pop</span> <span class='kw'>in</span> <span class='ident'>pops</span> {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>, <span class='ident'>pop</span>.<span class='ident'>city</span>, <span class='ident'>pop</span>.<span class='ident'>country</span>, <span class='ident'>pop</span>.<span class='ident'>count</span>);
        }
    }
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>)
}
...</pre>

<p>Now that we&#39;ve seen how to do proper error handling with <code>Box&lt;Error&gt;</code>, let&#39;s
try a different approach with our own custom error type. But first, let&#39;s take
a quick break from error handling and add support for reading from <code>stdin</code>.</p>

<h2 id='reading-from-stdin' class='section-header'><a href='#reading-from-stdin'>Reading from stdin</a></h2>
<p>In our program, we accept a single file for input and do one pass over the
data. This means we probably should be able to accept input on stdin. But maybe
we like the current format too—so let&#39;s have both!</p>

<p>Adding support for stdin is actually quite easy. There are only three things we
have to do:</p>

<ol>
<li>Tweak the program arguments so that a single parameter—the
city—can be accepted while the population data is read from stdin.</li>
<li>Modify the program so that an option <code>-f</code> can take the file, if it
is not passed into stdin.</li>
<li>Modify the <code>search</code> function to take an <em>optional</em> file path. When <code>None</code>,
it should know to read from stdin.</li>
</ol>

<p>First, here&#39;s the new usage:</p>
<span class='rusttest'>fn main() {
    fn print_usage(program: &amp;str, opts: Options) {
        println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;city&gt;&quot;, program)));
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>print_usage</span>(<span class='ident'>program</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>opts</span>: <span class='ident'>Options</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>opts</span>.<span class='ident'>usage</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;Usage: {} [options] &lt;city&gt;&quot;</span>, <span class='ident'>program</span>)));
}</pre>

<p>The next part is going to be only a little harder:</p>
<span class='rusttest'>fn main() {
    ...
    let mut opts = Options::new();
    opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);
    ...
    let file = matches.opt_str(&quot;f&quot;);
    let data_file = file.as_ref().map(Path::new);
    
    let city = if !matches.free.is_empty() {
        matches.free[0].clone()
    } else {
        print_usage(&amp;program, opts);
        return;
    };
    
    for pop in search(&amp;data_file, &amp;city) {
        println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
    }
    ...
}</span><pre class='rust rust-example-rendered'>
...
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
<span class='ident'>opts</span>.<span class='ident'>optopt</span>(<span class='string'>&quot;f&quot;</span>, <span class='string'>&quot;file&quot;</span>, <span class='string'>&quot;Choose an input file, instead of using STDIN.&quot;</span>, <span class='string'>&quot;NAME&quot;</span>);
<span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);
...
<span class='kw'>let</span> <span class='ident'>file</span> <span class='op'>=</span> <span class='ident'>matches</span>.<span class='ident'>opt_str</span>(<span class='string'>&quot;f&quot;</span>);
<span class='kw'>let</span> <span class='ident'>data_file</span> <span class='op'>=</span> <span class='ident'>file</span>.<span class='ident'>as_ref</span>().<span class='ident'>map</span>(<span class='ident'>Path</span>::<span class='ident'>new</span>);

<span class='kw'>let</span> <span class='ident'>city</span> <span class='op'>=</span> <span class='kw'>if</span> <span class='op'>!</span><span class='ident'>matches</span>.<span class='ident'>free</span>.<span class='ident'>is_empty</span>() {
    <span class='ident'>matches</span>.<span class='ident'>free</span>[<span class='number'>0</span>].<span class='ident'>clone</span>()
} <span class='kw'>else</span> {
    <span class='ident'>print_usage</span>(<span class='kw-2'>&amp;</span><span class='ident'>program</span>, <span class='ident'>opts</span>);
    <span class='kw'>return</span>;
};

<span class='kw'>for</span> <span class='ident'>pop</span> <span class='kw'>in</span> <span class='ident'>search</span>(<span class='kw-2'>&amp;</span><span class='ident'>data_file</span>, <span class='kw-2'>&amp;</span><span class='ident'>city</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>, <span class='ident'>pop</span>.<span class='ident'>city</span>, <span class='ident'>pop</span>.<span class='ident'>country</span>, <span class='ident'>pop</span>.<span class='ident'>count</span>);
}
...</pre>

<p>In this piece of code, we take <code>file</code> (which has the type
<code>Option&lt;String&gt;</code>), and convert it to a type that <code>search</code> can use, in
this case, <code>&amp;Option&lt;AsRef&lt;Path&gt;&gt;</code>. To do this, we take a reference of
file, and map <code>Path::new</code> onto it. In this case, <code>as_ref()</code> converts
the <code>Option&lt;String&gt;</code> into an <code>Option&lt;&amp;str&gt;</code>, and from there, we can
execute <code>Path::new</code> to the content of the optional, and return the
optional of the new value. Once we have that, it is a simple matter of
getting the <code>city</code> argument and executing <code>search</code>.</p>

<p>Modifying <code>search</code> is slightly trickier. The <code>csv</code> crate can build a
parser out of
<a href="http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader">any type that implements <code>io::Read</code></a>.
But how can we use the same code over both types? There&#39;s actually a
couple ways we could go about this. One way is to write <code>search</code> such
that it is generic on some type parameter <code>R</code> that satisfies
<code>io::Read</code>. Another way is to just use trait objects:</p>
<span class='rusttest'>fn main() {
    fn search&lt;P: AsRef&lt;Path&gt;&gt;
             (file_path: &amp;Option&lt;P&gt;, city: &amp;str)
             -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error+Send+Sync&gt;&gt; {
        let mut found = vec![];
        let input: Box&lt;io::Read&gt; = match *file_path {
            None =&gt; Box::new(io::stdin()),
            Some(ref file_path) =&gt; Box::new(try!(fs::File::open(file_path))),
        };
        let mut rdr = csv::Reader::from_reader(input);
        // The rest remains unchanged!
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>search</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>
         (<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>P</span><span class='op'>&gt;</span>, <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>)
         <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PopulationCount</span><span class='op'>&gt;</span>, <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Error</span><span class='op'>+</span><span class='ident'>Send</span><span class='op'>+</span><span class='ident'>Sync</span><span class='op'>&gt;&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>found</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    <span class='kw'>let</span> <span class='ident'>input</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>io</span>::<span class='ident'>Read</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>file_path</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>io</span>::<span class='ident'>stdin</span>()),
        <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>file_path</span>) <span class='op'>=&gt;</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>))),
    };
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>input</span>);
    <span class='comment'>// The rest remains unchanged!</span>
}</pre>

<h2 id='error-handling-with-a-custom-type' class='section-header'><a href='#error-handling-with-a-custom-type'>Error handling with a custom type</a></h2>
<p>Previously, we learned how to
<a href="#composing-custom-error-types">compose errors using a custom error type</a>.
We did this by defining our error type as an <code>enum</code> and implementing <code>Error</code>
and <code>From</code>.</p>

<p>Since we have three distinct errors (IO, CSV parsing and not found), let&#39;s
define an <code>enum</code> with three variants:</p>
<span class='rusttest'>fn main() {
    #[derive(Debug)]
    enum CliError {
        Io(io::Error),
        Csv(csv::Error),
        NotFound,
    }
}</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>CliError</span> {
    <span class='ident'>Io</span>(<span class='ident'>io</span>::<span class='ident'>Error</span>),
    <span class='ident'>Csv</span>(<span class='ident'>csv</span>::<span class='ident'>Error</span>),
    <span class='ident'>NotFound</span>,
}</pre>

<p>And now for impls on <code>Display</code> and <code>Error</code>:</p>
<span class='rusttest'>fn main() {
    impl fmt::Display for CliError {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            match *self {
                CliError::Io(ref err) =&gt; err.fmt(f),
                CliError::Csv(ref err) =&gt; err.fmt(f),
                CliError::NotFound =&gt; write!(f, &quot;No matching cities with a \
                                                 population were found.&quot;),
            }
        }
    }
    
    impl Error for CliError {
        fn description(&amp;self) -&gt; &amp;str {
            match *self {
                CliError::Io(ref err) =&gt; err.description(),
                CliError::Csv(ref err) =&gt; err.description(),
                CliError::NotFound =&gt; &quot;not found&quot;,
            }
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Display</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>fmt</span>(<span class='ident'>f</span>),
            <span class='ident'>CliError</span>::<span class='ident'>Csv</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>fmt</span>(<span class='ident'>f</span>),
            <span class='ident'>CliError</span>::<span class='ident'>NotFound</span> <span class='op'>=&gt;</span> <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;No matching cities with a \
                                             population were found.&quot;</span>),
        }
    }
}

<span class='kw'>impl</span> <span class='ident'>Error</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>description</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='ident'>str</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>description</span>(),
            <span class='ident'>CliError</span>::<span class='ident'>Csv</span>(<span class='kw-2'>ref</span> <span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='ident'>err</span>.<span class='ident'>description</span>(),
            <span class='ident'>CliError</span>::<span class='ident'>NotFound</span> <span class='op'>=&gt;</span> <span class='string'>&quot;not found&quot;</span>,
        }
    }
}</pre>

<p>Before we can use our <code>CliError</code> type in our <code>search</code> function, we need to
provide a couple <code>From</code> impls. How do we know which impls to provide? Well,
we&#39;ll need to convert from both <code>io::Error</code> and <code>csv::Error</code> to <code>CliError</code>.
Those are the only external errors, so we&#39;ll only need two <code>From</code> impls for
now:</p>
<span class='rusttest'>fn main() {
    impl From&lt;io::Error&gt; for CliError {
        fn from(err: io::Error) -&gt; CliError {
            CliError::Io(err)
        }
    }
    
    impl From&lt;csv::Error&gt; for CliError {
        fn from(err: csv::Error) -&gt; CliError {
            CliError::Csv(err)
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>io</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>io</span>::<span class='ident'>Error</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>Io</span>(<span class='ident'>err</span>)
    }
}

<span class='kw'>impl</span> <span class='ident'>From</span><span class='op'>&lt;</span><span class='ident'>csv</span>::<span class='ident'>Error</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>CliError</span> {
    <span class='kw'>fn</span> <span class='ident'>from</span>(<span class='ident'>err</span>: <span class='ident'>csv</span>::<span class='ident'>Error</span>) <span class='op'>-&gt;</span> <span class='ident'>CliError</span> {
        <span class='ident'>CliError</span>::<span class='ident'>Csv</span>(<span class='ident'>err</span>)
    }
}</pre>

<p>The <code>From</code> impls are important because of how
<a href="#code-try-def"><code>try!</code> is defined</a>. In particular, if an error occurs,
<code>From::from</code> is called on the error, which in this case, will convert it to our
own error type <code>CliError</code>.</p>

<p>With the <code>From</code> impls done, we only need to make two small tweaks to our
<code>search</code> function: the return type and the “not found” error. Here it is in
full:</p>
<span class='rusttest'>fn main() {
    fn search&lt;P: AsRef&lt;Path&gt;&gt;
             (file_path: &amp;Option&lt;P&gt;, city: &amp;str)
             -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {
        let mut found = vec![];
        let input: Box&lt;io::Read&gt; = match *file_path {
            None =&gt; Box::new(io::stdin()),
            Some(ref file_path) =&gt; Box::new(try!(fs::File::open(file_path))),
        };
        let mut rdr = csv::Reader::from_reader(input);
        for row in rdr.decode::&lt;Row&gt;() {
            let row = try!(row);
            match row.population {
                None =&gt; { } // skip it
                Some(count) =&gt; if row.city == city {
                    found.push(PopulationCount {
                        city: row.city,
                        country: row.country,
                        count: count,
                    });
                },
            }
        }
        if found.is_empty() {
            Err(CliError::NotFound)
        } else {
            Ok(found)
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>search</span><span class='op'>&lt;</span><span class='ident'>P</span>: <span class='ident'>AsRef</span><span class='op'>&lt;</span><span class='ident'>Path</span><span class='op'>&gt;&gt;</span>
         (<span class='ident'>file_path</span>: <span class='kw-2'>&amp;</span><span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>P</span><span class='op'>&gt;</span>, <span class='ident'>city</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>)
         <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PopulationCount</span><span class='op'>&gt;</span>, <span class='ident'>CliError</span><span class='op'>&gt;</span> {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>found</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[];
    <span class='kw'>let</span> <span class='ident'>input</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>io</span>::<span class='ident'>Read</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='op'>*</span><span class='ident'>file_path</span> {
        <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>io</span>::<span class='ident'>stdin</span>()),
        <span class='prelude-val'>Some</span>(<span class='kw-2'>ref</span> <span class='ident'>file_path</span>) <span class='op'>=&gt;</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>fs</span>::<span class='ident'>File</span>::<span class='ident'>open</span>(<span class='ident'>file_path</span>))),
    };
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>rdr</span> <span class='op'>=</span> <span class='ident'>csv</span>::<span class='ident'>Reader</span>::<span class='ident'>from_reader</span>(<span class='ident'>input</span>);
    <span class='kw'>for</span> <span class='ident'>row</span> <span class='kw'>in</span> <span class='ident'>rdr</span>.<span class='ident'>decode</span>::<span class='op'>&lt;</span><span class='ident'>Row</span><span class='op'>&gt;</span>() {
        <span class='kw'>let</span> <span class='ident'>row</span> <span class='op'>=</span> <span class='macro'>try</span><span class='macro'>!</span>(<span class='ident'>row</span>);
        <span class='kw'>match</span> <span class='ident'>row</span>.<span class='ident'>population</span> {
            <span class='prelude-val'>None</span> <span class='op'>=&gt;</span> { } <span class='comment'>// skip it</span>
            <span class='prelude-val'>Some</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> <span class='kw'>if</span> <span class='ident'>row</span>.<span class='ident'>city</span> <span class='op'>==</span> <span class='ident'>city</span> {
                <span class='ident'>found</span>.<span class='ident'>push</span>(<span class='ident'>PopulationCount</span> {
                    <span class='ident'>city</span>: <span class='ident'>row</span>.<span class='ident'>city</span>,
                    <span class='ident'>country</span>: <span class='ident'>row</span>.<span class='ident'>country</span>,
                    <span class='ident'>count</span>: <span class='ident'>count</span>,
                });
            },
        }
    }
    <span class='kw'>if</span> <span class='ident'>found</span>.<span class='ident'>is_empty</span>() {
        <span class='prelude-val'>Err</span>(<span class='ident'>CliError</span>::<span class='ident'>NotFound</span>)
    } <span class='kw'>else</span> {
        <span class='prelude-val'>Ok</span>(<span class='ident'>found</span>)
    }
}</pre>

<p>No other changes are necessary.</p>

<h2 id='adding-functionality' class='section-header'><a href='#adding-functionality'>Adding functionality</a></h2>
<p>Writing generic code is great, because generalizing stuff is cool, and
it can then be useful later. But sometimes, the juice isn&#39;t worth the
squeeze. Look at what we just did in the previous step:</p>

<ol>
<li>Defined a new error type.</li>
<li>Added impls for <code>Error</code>, <code>Display</code> and two for <code>From</code>.</li>
</ol>

<p>The big downside here is that our program didn&#39;t improve a whole lot.
There is quite a bit of overhead to representing errors with <code>enum</code>s,
especially in short programs like this.</p>

<p><em>One</em> useful aspect of using a custom error type like we&#39;ve done here is that
the <code>main</code> function can now choose to handle errors differently. Previously,
with <code>Box&lt;Error&gt;</code>, it didn&#39;t have much of a choice: just print the message.
We&#39;re still doing that here, but what if we wanted to, say, add a <code>--quiet</code>
flag? The <code>--quiet</code> flag should silence any verbose output.</p>

<p>Right now, if the program doesn&#39;t find a match, it will output a message saying
so. This can be a little clumsy, especially if you intend for the program to
be used in shell scripts.</p>

<p>So let&#39;s start by adding the flags. Like before, we need to tweak the usage
string and add a flag to the Option variable. Once we&#39;ve done that, Getopts does the rest:</p>
<span class='rusttest'>fn main() {
    ...
    let mut opts = Options::new();
    opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);
    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);
    opts.optflag(&quot;q&quot;, &quot;quiet&quot;, &quot;Silences errors and warnings.&quot;);
    ...
}</span><pre class='rust rust-example-rendered'>
...
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>opts</span> <span class='op'>=</span> <span class='ident'>Options</span>::<span class='ident'>new</span>();
<span class='ident'>opts</span>.<span class='ident'>optopt</span>(<span class='string'>&quot;f&quot;</span>, <span class='string'>&quot;file&quot;</span>, <span class='string'>&quot;Choose an input file, instead of using STDIN.&quot;</span>, <span class='string'>&quot;NAME&quot;</span>);
<span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;h&quot;</span>, <span class='string'>&quot;help&quot;</span>, <span class='string'>&quot;Show this usage message.&quot;</span>);
<span class='ident'>opts</span>.<span class='ident'>optflag</span>(<span class='string'>&quot;q&quot;</span>, <span class='string'>&quot;quiet&quot;</span>, <span class='string'>&quot;Silences errors and warnings.&quot;</span>);
...</pre>

<p>Now we just need to implement our “quiet” functionality. This requires us to
tweak the case analysis in <code>main</code>:</p>
<span class='rusttest'>fn main() {
    match search(&amp;args.arg_data_path, &amp;args.arg_city) {
        Err(CliError::NotFound) if args.flag_quiet =&gt; process::exit(1),
        Err(err) =&gt; panic!(&quot;{}&quot;, err),
        Ok(pops) =&gt; for pop in pops {
            println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);
        }
    }
}</span><pre class='rust rust-example-rendered'>
<span class='kw'>match</span> <span class='ident'>search</span>(<span class='kw-2'>&amp;</span><span class='ident'>args</span>.<span class='ident'>arg_data_path</span>, <span class='kw-2'>&amp;</span><span class='ident'>args</span>.<span class='ident'>arg_city</span>) {
    <span class='prelude-val'>Err</span>(<span class='ident'>CliError</span>::<span class='ident'>NotFound</span>) <span class='kw'>if</span> <span class='ident'>args</span>.<span class='ident'>flag_quiet</span> <span class='op'>=&gt;</span> <span class='ident'>process</span>::<span class='ident'>exit</span>(<span class='number'>1</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>),
    <span class='prelude-val'>Ok</span>(<span class='ident'>pops</span>) <span class='op'>=&gt;</span> <span class='kw'>for</span> <span class='ident'>pop</span> <span class='kw'>in</span> <span class='ident'>pops</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{}, {}: {:?}&quot;</span>, <span class='ident'>pop</span>.<span class='ident'>city</span>, <span class='ident'>pop</span>.<span class='ident'>country</span>, <span class='ident'>pop</span>.<span class='ident'>count</span>);
    }
}</pre>

<p>Certainly, we don&#39;t want to be quiet if there was an IO error or if the data
failed to parse. Therefore, we use case analysis to check if the error type is
<code>NotFound</code> <em>and</em> if <code>--quiet</code> has been enabled. If the search failed, we still
quit with an exit code (following <code>grep</code>&#39;s convention).</p>

<p>If we had stuck with <code>Box&lt;Error&gt;</code>, then it would be pretty tricky to implement
the <code>--quiet</code> functionality.</p>

<p>This pretty much sums up our case study. From here, you should be ready to go
out into the world and write your own programs and libraries with proper error
handling.</p>

<h1 id='the-short-story' class='section-header'><a href='#the-short-story'>The Short Story</a></h1>
<p>Since this chapter is long, it is useful to have a quick summary for error
handling in Rust. These are some good “rules of thumb.&quot; They are emphatically
<em>not</em> commandments. There are probably good reasons to break every one of these
heuristics!</p>

<ul>
<li>If you&#39;re writing short example code that would be overburdened by error
handling, it&#39;s probably just fine to use <code>unwrap</code> (whether that&#39;s
<a href="../std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>,
<a href="../std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a>
or preferably
<a href="../std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>).
Consumers of your code should know to use proper error handling. (If they
don&#39;t, send them here!)</li>
<li>If you&#39;re writing a quick &#39;n&#39; dirty program, don&#39;t feel ashamed if you use
<code>unwrap</code>. Be warned: if it winds up in someone else&#39;s hands, don&#39;t be
surprised if they are agitated by poor error messages!</li>
<li>If you&#39;re writing a quick &#39;n&#39; dirty program and feel ashamed about panicking
anyway, then use either a <code>String</code> or a <code>Box&lt;Error + Send + Sync&gt;</code> for your
error type (the <code>Box&lt;Error + Send + Sync&gt;</code> type is because of the
<a href="../std/convert/trait.From.html">available <code>From</code> impls</a>).</li>
<li>Otherwise, in a program, define your own error types with appropriate
<a href="../std/convert/trait.From.html"><code>From</code></a>
and
<a href="../std/error/trait.Error.html"><code>Error</code></a>
impls to make the <a href="../std/macro.try!.html"><code>try!</code></a>
macro more ergonomic.</li>
<li>If you&#39;re writing a library and your code can produce errors, define your own
error type and implement the
<a href="../std/error/trait.Error.html"><code>std::error::Error</code></a>
trait. Where appropriate, implement
<a href="../std/convert/trait.From.html"><code>From</code></a> to make both
your library code and the caller&#39;s code easier to write. (Because of Rust&#39;s
coherence rules, callers will not be able to impl <code>From</code> on your error type,
so your library should do it.)</li>
<li>Learn the combinators defined on
<a href="../std/option/enum.Option.html"><code>Option</code></a>
and
<a href="../std/result/enum.Result.html"><code>Result</code></a>.
Using them exclusively can be a bit tiring at times, but I&#39;ve personally
found a healthy mix of <code>try!</code> and combinators to be quite appealing.
<code>and_then</code>, <code>map</code> and <code>unwrap_or</code> are my favorites.</li>
</ul>

    <script type="text/javascript">
        window.playgroundUrl = "https://play.rust-lang.org";
    </script>
    <script src='rustbook.js'></script>
<script src='playpen.js'></script>
</div></div>


</body>
</html>